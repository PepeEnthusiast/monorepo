import*as t from"@bitcoin-computer/tiny-secp256k1";import{networks as e,bufferUtils as s,Transaction as n,crypto as a,address as o,initEccLib as r}from"@bitcoin-computer/nakamotojs";import{backOff as i}from"exponential-backoff";import{Computer as c}from"@bitcoin-computer/lib";import u from"dotenv";import p from"fs";import l from"winston";import d from"winston-daily-rotate-file";import m from"bitcoind-rpc";import y from"util";import E from"pg-promise";import h from"pg-monitor";u.config();const S=JSON.parse(p.readFileSync("package.json","utf8"));const{PORT:O,ZMQ_URL:R,CHAIN:f,NETWORK:w,BCN_ENV:v,BCN_URL:T,DEBUG_MODE:$,POSTGRES_USER:g,POSTGRES_PASSWORD:I,POSTGRES_DB:M,POSTGRES_HOST:b,POSTGRES_PORT:N,RPC_PROTOCOL:x,RPC_USER:L,RPC_PASSWORD:C,RPC_HOST:A,RPC_PORT:B,SERVER_VERSION:P,DEFAULT_WALLET:k,POSTGRES_MAX_PARAM_NUM:D,DB_CONNECTION_RETRY_TIME:H,SIGNATURE_FRESHNESS_MINUTES:_,ALLOWED_RPC_METHODS:U,MAX_BLOCKCHAIN_HEIGHT:F,MWEB_HEIGHT:Y,WORKER_ID:W,NUM_WORKERS:K,ZMQ_WAIT_PERCENTAGE:G,QUERY_LIMIT:V,LOG_MAX_FILE_SIZE:j,LOG_MAX_FILE_NUM:q,LOG_ZIP:z}=process.env;const J=parseInt(O,10)||"1031";const X=f||"LTC";const Z=w||"regtest";const Q=v||"dev";const tt=T||`http://127.0.0.1:${J}`;const et=parseInt($,10)||1;const st=g||"bcn";const nt=I||"bcn";const at=M||"bcn";const ot=b||"127.0.0.1";const rt=parseInt(N,10)||"5432";const it=x||"http";const ct=L||"bcn-admin";const ut=C||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const pt=A||"node";const lt=parseInt(B,10)||19332;S.version;const dt=parseInt(D,10)||1e4;const mt=parseInt(H,10)||500;!U||U.split(",").map((t=>new RegExp(t)));const yt=parseInt(W,10)||1;const Et=parseInt(K||"",10)||1;const ht=parseInt(V||"",10)||1e3;const St=j||"20m";const Ot=q||"14d";const Rt=!!z;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const ft=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const wt={zippedArchive:Rt,maxSize:St,maxFiles:Ot,dirname:"logs"};const vt=[];"dev"===Q&&vt.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),et>=0&&vt.push(new d({filename:`error${yt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"error",...wt})),et>=1&&vt.push(new d({filename:`warn${yt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"warn",...wt})),et>=2&&vt.push(new d({filename:`info${yt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"info",...wt})),et>=3&&vt.push(new d({filename:`http${yt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"http",...wt})),et>=4&&vt.push(new d({filename:`debug${yt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"debug",...wt}));const Tt=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:ft,transports:vt,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const $t=new m({protocol:it,user:ct,pass:ut,host:pt,port:lt});const gt=y.promisify(m.prototype.createwallet.bind($t));const It=y.promisify(m.prototype.generateToAddress.bind($t));const Mt=y.promisify(m.prototype.getaddressinfo.bind($t));const bt=y.promisify(m.prototype.getBlock.bind($t));const Nt=y.promisify(m.prototype.getBlockchainInfo.bind($t));const xt=y.promisify(m.prototype.getBlockHash.bind($t));const Lt=y.promisify(m.prototype.getRawTransaction.bind($t));const Ct=y.promisify(m.prototype.getRawTransaction.bind($t));const At=y.promisify(m.prototype.getTransaction.bind($t));const Bt=y.promisify(m.prototype.getNewAddress.bind($t));const Pt={createwallet:gt,generateToAddress:It,getaddressinfo:Mt,getBlock:bt,getBlockchainInfo:Nt,getBlockHash:xt,getRawTransaction:Lt,getTransaction:At,importaddress:y.promisify(m.prototype.importaddress.bind($t)),listunspent:y.promisify(m.prototype.listunspent.bind($t)),sendRawTransaction:y.promisify(m.prototype.sendRawTransaction.bind($t)),getNewAddress:Bt,sendToAddress:y.promisify(m.prototype.sendToAddress.bind($t)),getRawTransactionJSON:Ct};const kt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:o,password:r}=e.cn;Tt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${o}, password: ${r}`)}},noWarnings:!0};"dev"===Q&&et>0&&(h.isAttached()?h.detach():(h.attach(kt),h.setTheme("matrix")));const Dt=E(kt)({host:ot,port:rt,database:at,user:st,password:nt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Ht}=E;class _t{static async select(t){const e=new Ht({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "workerId" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return Dt.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new Ht({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await Dt.any(s)}static async count(){const t=new Ht({name:`SyncStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "SyncStatus"'});const e=await Dt.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(){const t=new Ht({name:`SyncStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "SyncStatus"'});const e=await Dt.oneOrNone(t);return parseInt(e?.min,10)||0}static async delete(){const t=new Ht({name:`SyncStatus.delete.${Math.random()}`,text:'DELETE FROM "SyncStatus"'});await Dt.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=2)e.push(`($${s}, $${s+1})`);const s=e.join(",");const n=new Ht({name:`SyncStatus.reorg.${Math.random()}`,text:`INSERT INTO "SyncStatus"("workerId", "blockToSync") VALUES ${s}`,values:t});await Dt.any(n)}}class Ut{static async select(t){return _t.select(t)}static async update(t){await _t.update(t)}static async count(){return _t.count()}static async insertBatch(t){await _t.insertBatch(t)}static async min(){return _t.min()}static async delete(){await _t.delete()}}class Ft{static update=async t=>Ut.update(t);static select=async t=>Ut.select(t);static setup=async t=>{if(await Ut.count()===t)return;const e=[];let s=Math.max(1,await Ut.min());for(let n=1;n<=t;n+=1,s+=1)e.push(n,s);await Ut.delete(),await Ut.insertBatch(e)};static waitUntilSetup=async t=>{i((async()=>{if(await Ut.count()===t)return!0;throw new Error("Not all workers have reorged")}),{startingDelay:500})}}const{PreparedStatement:Yt}=E;class Wt{static async select(t){const e=new Yt({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return Dt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,dt);const s=[];for(let e=1;e<=t.length;e+=2)s.push(`($${e}, $${e+1})`);const n=s.join(",");const a=new Yt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await Dt.none(a)}}static async count(t){const e=t.map((t=>t.outputSpent));const s=new Yt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const n=await Dt.oneOrNone(s);return parseInt(n?.count,10)||0}}class Kt{static async select(t){return Wt.select(t)}static async insert(t){return Wt.insert(t)}}class Gt{static getNonCoinbaseRevs=t=>t.filter((t=>!n.isCoinbaseHash(t.input.hash))).map((({input:t,txId:e},n)=>{return{outputSpent:`${a=t.hash,s.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${e}:${n}`};var a}));static insert=async t=>{const e=t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId})))));Kt.insert(this.getNonCoinbaseRevs(e))}}function Vt(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:jt}=E;class qt{static async listSentOutputs(t){const e=new jt({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await Dt.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new jt({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await Dt.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new jt({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await Dt.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new jt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", "publicKeys", "hash", "mod", "isTbcOutput", "previous" FROM "Output" WHERE "address" = $1',values:[t]});return Dt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys,t.hash,t.mod,t.isTbcOutput,t.previous]));for(;e.length;){const t=e.splice(0,dt);const s=[];for(let e=1;e<=t.length;e+=9)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4}, $${e+5}, $${e+6}, $${e+7}, $${e+8})`);const n=s.join(",");const a=new jt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys", "hash", "mod", "isTbcOutput", "previous") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Dt.none(a)}}static async getIdByRev(t){const e=new jt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await Dt.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new jt({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await Dt.any(e);const n=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let a=t;for(;n[a];)a=n[a];return a}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new jt({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await Dt.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let n="";return s&&(n+=` order by "timestamp" ${s}`),n+=` limit ${t||ht}`,e&&(n+=` offset ${e}`),n}static async getRevsByPublicKey(t){const e=new jt({name:`Output.getRevsByPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys")',values:[t]});return(await Dt.any(e)).map((t=>t.rev))}static async getUnspentRevsByMod(t,e,s,n){const a=await this.getIdsByMod(t);const o=await this.getLatestRevs(a);const r=new jt({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,n)}`,values:[o]});return(await Dt.any(r)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,n){const a=new jt({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys") AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,n)}`,values:[t]});return(await Dt.any(a)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,n,a){const o=await this.getUnspentRevsByPublicKey(e,s,n,a);const r=await this.getIdsByRevs(o);const i=new jt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,r]});const c=(await Dt.any(i)).map((t=>t.rev));const u=await this.getLatestRevs(c);const p=new jt({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,n,a)}`,values:[u]});return(await Dt.any(p)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:n,ids:a,mod:o,order:r}=t;if(s&&parseInt(s||"",10)>ht||a&&a.length>ht)throw new Error(`Can't fetch more than ${ht} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order. Should be ASC or DESC.");return a?.length?(a.map(Vt),this.getLatestRevs(a)):o&&!e?this.getUnspentRevsByMod(o,s,n,r):!o&&e?this.getUnspentRevsByPublicKey(e,s,n,r):o&&e?this.getUnspentRevsByModAndPublicKey(o,e,s,n,r):[]}}class zt{static async select(t){return qt.select(t)}static async insert(t){return qt.insert(t)}static async listSentOutputs(t){return qt.listSentOutputs(t)}static async listReceivedOutputs(t){return qt.listReceivedOutputs(t)}static async listTxs(t){return qt.listTxs(t)}static async getLatestRev(t){return qt.getLatestRev(t)}static async query(t){return qt.query(t)}}class Jt{static insert=async t=>{const s=t.flatMap((t=>{let s=[];let n=[];try{({zip:s,outData:n}=t)}catch(t){}return t.tx.outs.map(((r,i)=>{const{script:c}=r;let u=null;let p=null;let l=!1;let d=null;let m="";let y=[];let E="";if(i<s.length){const[e,o]=s[i];if(p=e,l=!0,E=n[i]?.exp||"",m=n[i]?.mod||"",d=a.sha256(Buffer.from(E)).toString("hex"),y=n[i]?._owners||[],o!==`${t.txId}:${i}`)throw new Error(`outRev: ${s[i].outRev} !== ${t.txId}:${i}`)}try{u=o.fromOutputScript(c,function(t,s){switch(X){case"BTC":return"mainnet"===s?e.bitcoin:e.testnet;case"LTC":return"mainnet"===s?e.litecoin:e.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}(0,Z))}catch(t){}const h=c.toString("hex");const S=Math.round(r.value);return{address:u,rev:`${t.txId}:${i}`,scriptPubKey:h,satoshis:S,publicKeys:y,hash:d,previous:p,mod:m,isTbcOutput:l}}))}));return zt.insert(s)};static listSentOutputs=async t=>zt.listSentOutputs(t);static listReceivedOutputs=async t=>zt.listReceivedOutputs(t);static listTxs=async t=>zt.listTxs(t);static getLatestRev=async t=>zt.getLatestRev(t);static query=async t=>zt.query(t)}const Xt=new c({chain:X,network:Z,url:tt});class Zt{static waitForBlockHash=async t=>(await i((async()=>{let e;try{e=await Pt.getBlockHash(t)}catch(e){throw Tt.info(`Sync workerId ${yt}: waiting for block ${t} ...`),e}return e}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720})).result;static syncBlock=async(t,e="LTC")=>{const s=await Zt.waitForBlockHash(t);const{result:n}=await Pt.getBlock(s,2);const{tx:a}=n;let o=a;"LTC"===e&&(o=a.filter((t=>"08"!==t.hex.slice(10,12))));const r=`Backfilling progress ${t} Backfilling ${o.length} txs `;"LTC"===e&&r.concat(`(${a.length-o.length} mweb tx's filtered)...`),Tt.info(r);const i=await Promise.allSettled(o.map((t=>Xt.txFromHex({hex:t.hex}))));const c=i.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const u=i.filter((t=>"rejected"===t.status)).map((t=>t.reason));var p,l;u.length&&Tt.error(`Failed to parse ${u.length} transactions of block num ${t}: ${u.map((t=>t)).join(", ")}\n        Failed txs: ${p=o.map((t=>t.id)),l=c.map((t=>t.tx.getId())),p.filter((t=>-1===l.indexOf(t)))}`),await this.syncTxs(c,t)};static sync=async(t,e)=>{for(;;){try{await this.syncBlock(e,X)}catch(t){Tt.error(`Syncing block num ${e} failed with error '${t.message}'`)}e+=Et,await Ft.update({blockToSync:e,workerId:t})}};static syncTxs=async(t,e)=>{try{await Jt.insert(t),await Gt.insert(t)}catch(t){Tt.error(`Processing block ${e} failed with error '${t.message}'`)}}}r(t),function(){try{const t=`Synchronizing { url: ${tt}, chain:${X} network:${Z} numWorkers: ${Et} workerId: ${yt}}`;Tt.info(t),"regtest"!==Z&&(async()=>{await(async()=>{await i((()=>Dt.connect()),{startingDelay:mt})})(),Tt.info(`Worker ${yt} connected to the database successfully. Setting up syncStatus table...`),1===yt?await Ft.setup(Et):await Ft.waitUntilSetup(Et);const t=await Ft.select(yt);Tt.info(`WorkerId ${t.workerId} starting sync on blockToSync: ${t.blockToSync} - numWorkers: ${Et}`),await Zt.sync(t.workerId,t.blockToSync)})()}catch(t){Tt.error(`Synchronizing failed with error '${t.message}'`)}}();
