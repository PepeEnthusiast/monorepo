import*as t from"@bitcoin-computer/tiny-secp256k1";import{networks as e,bufferUtils as n,crypto as s,Transaction as a,address as r,payments as o,initEccLib as i}from"@bitcoin-computer/nakamotojs";import{backOff as c}from"exponential-backoff";import{Computer as u}from"@bitcoin-computer/lib";import d from"dotenv";import p from"fs";import l from"winston";import m from"winston-daily-rotate-file";import h from"bitcoind-rpc";import y from"util";import S from"pg-promise";import E from"pg-monitor";d.config();const w=JSON.parse(p.readFileSync("package.json","utf8"));function $(t,n){switch(t){case"BTC":return"mainnet"===n?e.bitcoin:e.testnet;case"LTC":return"mainnet"===n?e.litecoin:e.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}const{PORT:f,ZMQ_URL:I,CHAIN:T,NETWORK:g,BCN_ENV:O,BCN_URL:R,DEBUG_MODE:N,POSTGRES_USER:v,POSTGRES_PASSWORD:M,POSTGRES_DB:b,POSTGRES_HOST:x,POSTGRES_PORT:C,RPC_PROTOCOL:k,RPC_USER:A,RPC_PASSWORD:L,RPC_HOST:D,RPC_PORT:_,SERVER_VERSION:H,DEFAULT_WALLET:P,POSTGRES_MAX_PARAM_NUM:B,DB_CONNECTION_RETRY_TIME:Y,SIGNATURE_FRESHNESS_MINUTES:F,ALLOWED_RPC_METHODS:W,MAX_BLOCKCHAIN_HEIGHT:U,MWEB_HEIGHT:G,BC_START_HEIGHT:K,WORKER_ID:V,NUM_WORKERS:j,SYNC_NON_STANDARD:z,ZMQ_WAIT_PERCENTAGE:q,QUERY_LIMIT:J,LOG_MAX_FILE_SIZE:Z,LOG_MAX_FILE_NUM:X,LOG_ZIP:Q}=process.env;const tt=parseInt(f,10)||"1031";const et=T||"LTC";const nt=g||"regtest";const st=O||"dev";const at=R||`http://127.0.0.1:${tt}`;const rt=parseInt(N,10)||1;const ot=v||"bcn";const it=M||"bcn";const ct=b||"bcn";const ut=x||"127.0.0.1";const dt=parseInt(C,10)||"5432";const pt=k||"http";const lt=A||"bcn-admin";const mt=L||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const ht=D||"node";const yt=parseInt(_,10)||19332;w.version;const St=parseInt(B,10)||1e4;const Et=parseInt(Y,10)||500;!W||W.split(",").map((t=>new RegExp(t)));const wt=parseInt(K||"",10)||25e5;const $t=parseInt(V,10)||1;const ft=parseInt(j||"",10)||1;const It="true"===z||!1;const Tt=parseInt(J||"",10)||1e3;const gt=Z||"20m";const Ot=X||"14d";const Rt=!!Q;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Nt=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const vt={zippedArchive:Rt,maxSize:gt,maxFiles:Ot,dirname:"logs"};const Mt=[];"dev"===st&&Mt.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),rt>=0&&Mt.push(new m({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...vt})),rt>=1&&Mt.push(new m({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...vt})),rt>=2&&Mt.push(new m({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...vt})),rt>=3&&Mt.push(new m({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...vt})),rt>=4&&Mt.push(new m({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...vt}));const bt=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Nt,transports:Mt,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const xt=new h({protocol:pt,user:lt,pass:mt,host:ht,port:yt});const Ct=y.promisify(h.prototype.createwallet.bind(xt));const kt=y.promisify(h.prototype.generateToAddress.bind(xt));const At=y.promisify(h.prototype.getaddressinfo.bind(xt));const Lt=y.promisify(h.prototype.getBlock.bind(xt));const Dt=y.promisify(h.prototype.getBlockchainInfo.bind(xt));const _t=y.promisify(h.prototype.getBlockHash.bind(xt));const Ht=y.promisify(h.prototype.getRawTransaction.bind(xt));const Pt=y.promisify(h.prototype.getRawTransaction.bind(xt));const Bt=y.promisify(h.prototype.getTransaction.bind(xt));const Yt=y.promisify(h.prototype.getNewAddress.bind(xt));const Ft={createwallet:Ct,generateToAddress:kt,getaddressinfo:At,getBlock:Lt,getBlockchainInfo:Dt,getBlockHash:_t,getRawTransaction:Ht,getTransaction:Bt,importaddress:y.promisify(h.prototype.importaddress.bind(xt)),listunspent:y.promisify(h.prototype.listunspent.bind(xt)),sendRawTransaction:y.promisify(h.prototype.sendRawTransaction.bind(xt)),getNewAddress:Yt,sendToAddress:y.promisify(h.prototype.sendToAddress.bind(xt)),getRawTransactionJSON:Pt};const Wt={error:(t,e)=>{if(e.cn){const{host:n,port:s,database:a,user:r,password:o}=e.cn;bt.debug(`Waiting for db to start { message:${t.message} host:${n}, port:${s}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===st&&rt>0&&(E.isAttached()?E.detach():(E.attach(Wt),E.setTheme("matrix")));const Ut=S(Wt)({host:ut,port:dt,database:ct,user:ot,password:it,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Gt}=S;class Kt{static async select(t){const e=new Gt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "nonStandard", "workerId" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return Ut.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const n=new Gt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await Ut.any(n)}static async count(){const t=new Gt({name:`SyncStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "SyncStatus"'});const e=await Ut.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(t){const e=new Gt({name:`SyncStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "SyncStatus" where "nonStandard" = $1',values:[t]});const n=await Ut.oneOrNone(e);return parseInt(n?.min,10)||0}static async delete(){const t=new Gt({name:`SyncStatus.delete.${Math.random()}`,text:'DELETE FROM "SyncStatus"'});await Ut.any(t)}static async insertBatch(t){const e=[];for(let n=1;n<=t.length;n+=3)e.push(`($${n}, $${n+1}, $${n+2})`);const n=e.join(",");const s=new Gt({name:`SyncStatus.reorg.${Math.random()}`,text:`INSERT INTO "SyncStatus"("workerId", "blockToSync", "nonStandard") VALUES ${n}`,values:t});await Ut.any(s)}}class Vt{static async select(t){return Kt.select(t)}static async update(t){await Kt.update(t)}static async count(){return Kt.count()}static async insertBatch(t){await Kt.insertBatch(t)}static async minStandard(){return Kt.min(!1)}static async minNonStandard(){return Kt.min(!0)}static async delete(){await Kt.delete()}}class jt{static update=async t=>Vt.update(t);static select=async t=>Vt.select(t);static setup=async t=>{if(await Vt.count()===t)return;const e=[];const n=Math.max(wt,await Vt.minNonStandard());let s=Math.max(1,await Vt.minStandard());for(let n=1;n<t;n+=1,s+=1)e.push(n,s,!1);e.push(t,n,!0),await Vt.delete(),await Vt.insertBatch(e)};static waitUntilSetup=async t=>{c((async()=>{if(await Vt.count()===t)return!0;throw new Error("Not all workers have reorged")}),{startingDelay:500})}}function zt(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:qt}=S;class Jt{static async query(t){const{publicKey:e,hash:n,limit:s,offset:a,order:r,ids:o,mod:i}=t;if(s&&parseInt(s||"",10)>Tt||o&&o.length>Tt)throw new Error(`Can't fetch more than ${Tt} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let c;c=o?.length?'SELECT "rev", "id", array_position($1, "id") as ord\n        FROM "NonStandard" \n        WHERE true ':'SELECT "rev"\n        FROM "NonStandard"\n        WHERE true ';const u=[];n&&(u.push(n),c+=` AND "hash" = $${u.length}`),i&&(u.push(i),c+=` AND "mod" = $${u.length}`),o&&(o.map(zt),u.push(o),c+=` AND "id" = ANY ($${u.length})`),e&&(u.push(e),c+=` AND $${u.length} = ANY ("publicKeys")`),r?(c+=` order by "lastUpdated" ${r}`,o?.length&&(c+=", ord")):o?.length&&(c+=" order by ord"),u.push(s||Tt),c+=` limit $${u.length}`,a&&(u.push(a),c+=` offset $${u.length}`);const d=new qt({name:`NonStandard.query.${Math.random()}`,text:c,values:u});return(await Ut.any(d)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:n,hash:s,mod:a}){const r=new qt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,n,s,a]});await Ut.none(r)}static async update({id:t,rev:e,publicKeys:n}){const s=new qt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,n]});return Ut.none(s)}static async delete({rev:t}){const e=new qt({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await Ut.none(e)}static async getRevsByIds(t){if(t&&t.length>Tt)throw new Error(`Can't fetch more than ${Tt} revs.`);const e=new qt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Ut.any(e)}static async select(t){const e=new qt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Ut.oneOrNone(e)}}class Zt{static async select(t){return Jt.select(t)}static async query(t){return Jt.query(t)}static async getRevsByIds(t){return Jt.getRevsByIds(t)}static async insert(t){return Jt.insert(t)}static async update(t){return Jt.update(t)}static async delete(t){return Jt.delete({rev:t})}}const{PreparedStatement:Xt}=S;class Qt{static async getId(t){const e=new Xt({name:`RevToId.select.${Math.random()}`,text:'SELECT "id" FROM "RevToId" WHERE "rev" = $1',values:[t]});const n=await Ut.oneOrNone(e);return n?.id}static async insert(t){const e=new Xt({name:`RevToId.insert.${Math.random()}`,text:'INSERT INTO "RevToId"("rev", "id") VALUES ($1, $2)  ON CONFLICT DO NOTHING',values:[t.rev,t.id]});await Ut.none(e)}}class te{static async getId(t){return Qt.getId(t)}static async insert(t){return Qt.insert(t)}}class ee{static add=async t=>{let e;let n;try{({zip:e,outData:n}=t)}catch{return}for(let t=0;t<e.length;t+=1){const[a,r]=e[t];const{exp:o="",_owners:i=[],mod:c=""}=n[t]||{};if(!a&&r)zt(r),await Zt.insert({id:r,rev:r,publicKeys:i,hash:s.sha256(Buffer.from(o)).toString("hex"),mod:c}),await te.insert({rev:r,id:r});else if(a&&r){const{id:t,hash:e,mod:n}=await Zt.select(a)||{};await Zt.update({id:t,rev:r,publicKeys:i,hash:e,mod:n}),await te.insert({rev:r,id:t})}else a&&!r&&await Zt.delete(a)}};static query=async t=>Zt.query(t);static getRevsByIds=async t=>(await Zt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:ne}=S;class se{static async select(t){const e=new ne({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return Ut.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,St);const n=[];for(let e=1;e<=t.length;e+=2)n.push(`($${e}, $${e+1})`);const s=n.join(",");const a=new ne({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${s} ON CONFLICT DO NOTHING`,values:t});await Ut.none(a)}}static async count(t){const e=t.map((t=>t.outputSpent));const n=new ne({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const s=await Ut.oneOrNone(n);return parseInt(s?.count,10)||0}}class ae{static async select(t){return se.select(t)}static async insert(t){return se.insert(t)}}class re{static getNonCoinbaseRevs=t=>t.filter((t=>!a.isCoinbaseHash(t.input.hash))).map((({input:t,txId:e},s)=>{return{outputSpent:`${a=t.hash,n.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${e}:${s}`};var a}));static insert=async t=>{const e=t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId})))));ae.insert(this.getNonCoinbaseRevs(e))}}const{PreparedStatement:oe}=S;class ie{static async listSentOutputs(t){const e=new oe({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await Ut.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new oe({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await Ut.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new oe({name:`Output.listTxs.${Math.random()}`,text:' -- List all txs sent from a given address\n            WITH SENT AS (\n              SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n              FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n              WHERE "Output".address = $1\n              GROUP BY split_part("Input"."spendingInput",\':\',1)\n            )\n            \n            -- List all tx received from a given address\n            , RECEIVED AS (\n              SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n              FROM "Output" \n              WHERE "address" = $1\n              GROUP BY "txId"\n            )\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n                SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId" ;',values:[t]});const n=(await Ut.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:n.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:n.filter((t=>t.satoshis>=0))}}static async select(t){const e=new oe({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Ut.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys]));for(;e.length;){const t=e.splice(0,St);const n=[];for(let e=1;e<=t.length;e+=5)n.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const s=n.join(",");const a=new oe({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys") VALUES ${s}  ON CONFLICT DO NOTHING`,values:t});await Ut.none(a)}}}class ce{static async select(t){return ie.select(t)}static async insert(t){return ie.insert(t)}static async listSentOutputs(t){return ie.listSentOutputs(t)}static async listReceivedOutputs(t){return ie.listReceivedOutputs(t)}static async listTxs(t){return ie.listTxs(t)}}class ue{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,n)=>{const{script:s}=e;let a;let i;try{a=r.fromOutputScript(s,$(et,nt))}catch(t){a=null}try{i=o.p2ms({output:s,network:$(et,nt)}).pubkeys.map((t=>t.toString("hex"))),i.some((t=>t.length>66))&&(i=null)}catch(t){i=null}const c=s.toString("hex");const u=Math.round(e.value);return{address:a,rev:`${t.txId}:${n}`,scriptPubKey:c,satoshis:u,publicKeys:i}}))));return ce.insert(e)};static listSentOutputs=async t=>ce.listSentOutputs(t);static listReceivedOutputs=async t=>ce.listReceivedOutputs(t);static listTxs=async t=>ce.listTxs(t)}const de=new u({chain:et,network:nt,url:at});class pe{static waitForBlockHash=async t=>(await c((async()=>{let e;try{e=await Ft.getBlockHash(t)}catch(e){throw bt.info(`Sync workerId ${$t}: waiting for block ${t} ...`),e}return e}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720})).result;static syncBlock=async(t,e="LTC")=>{const n=await pe.waitForBlockHash(t);const{result:s}=await Ft.getBlock(n,2);const{tx:a}=s;let r=a;"LTC"===e&&(r=a.filter((t=>"08"!==t.hex.slice(10,12))));const o=`Backfilling progress ${t} Backfilling ${r.length} txs `;"LTC"===e&&o.concat(`(${a.length-r.length} mweb tx's filtered)...`),bt.info(o);const i=await Promise.allSettled(r.map((t=>de.txFromHex({hex:t.hex}))));const c=i.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const u=i.filter((t=>"rejected"===t.status)).map((t=>t.reason));var d,p;u.length&&bt.error(`Failed to parse ${u.length} transactions of block num ${t}: ${u.map((t=>t)).join(", ")}\n        Failed txs: ${d=r.map((t=>t.id)),p=c.map((t=>t.tx.getId())),d.filter((t=>-1===p.indexOf(t)))}`),await this.syncTxs(c,t)};static sync=async(t,e,n,s,a)=>{for(;s||e<a;){try{await this.syncBlock(e,et)}catch(t){bt.error(`Syncing block num ${e} failed with error '${t.message}'`)}e+=n,await jt.update({blockToSync:e,workerId:t})}bt.info(`Sync workerId ${t} finished syncing up to block ${e}`)};static syncTxs=async(t,e)=>{try{await ue.insert(t),await re.insert(t),e>=wt&&t.map((async t=>{try{await ee.add(t)}catch(e){bt.error(`Failed to add non-standard tx ${t.tx.getId()} ${e.message}`)}}))}catch(t){bt.error(`Processing block ${e} failed with error '${t.message}'`)}}}i(t),function(){try{const t=`Synchronizing { nonStandard:${It} url: ${at}, chain:${et} network:${nt} numWorkers: ${ft} workerId: ${$t} activationHeight: ${wt} }`;bt.info(t),"regtest"!==nt&&(async()=>{const t=ft-1;if(await(async()=>{await c((()=>Ut.connect()),{startingDelay:Et})})(),bt.info(`Worker ${$t} connected to the database successfully. Setting up syncStatus table...`),ft<2)throw new Error(`At least two workers are needed to sync the blockchain. Please check the configuration. ${ft} workers are configured.`);1===$t?await jt.setup(ft):await jt.waitUntilSetup(ft);const e=await jt.select($t);const n=e.nonStandard?1:t;bt.info(`WorkerId ${e.workerId} starting sync on blockToSync: ${e.blockToSync} - \n     increment: ${n} - sycNonStandard: ${e.nonStandard} - numWorkers: ${ft} - num standard workers: ${t}`),await pe.sync(e.workerId,e.blockToSync,n,e.nonStandard,wt)})()}catch(t){bt.error(`Synchronizing failed with error '${t.message}'`)}}();
