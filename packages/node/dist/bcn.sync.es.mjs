import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import n from"dotenv";import s from"fs";import{networks as a,crypto as r,Transaction as o,bufferUtils as i,address as c,payments as d}from"@bitcoin-computer/nakamotojs-lib";import l from"winston";import p from"winston-daily-rotate-file";import m from"bitcoind-rpc";import u from"util";import y from"pg-promise";import h from"pg-monitor";n.config();const g=JSON.parse(s.readFileSync("package.json","utf8"));function f(t,e){switch(t){case"BTC":return"mainnet"===e?a.bitcoin:a.testnet;case"LTC":return"mainnet"===e?a.litecoin:a.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}const{PORT:w,ZMQ_URL:E,CHAIN:$,NETWORK:S,BCN_ENV:T,BCN_URL:R,DEBUG_MODE:I,POSTGRES_USER:N,POSTGRES_PASSWORD:v,POSTGRES_DB:O,POSTGRES_HOST:b,POSTGRES_PORT:M,RPC_PROTOCOL:C,RPC_USER:H,RPC_PASSWORD:_,RPC_HOST:A,RPC_PORT:D,SERVER_VERSION:x,DEFAULT_WALLET:k,SYNC_INTERVAL_CHECK:P,POSTGRES_MAX_PARAM_NUM:L,DB_CONNECTION_RETRY_TIME:Y,SIGNATURE_FRESHNESS_MINUTES:B,ALLOWED_RPC_METHODS:F,NODE_MAX_PROGRESS:W,SYNC_MAX_PROGRESS:K,MAX_BLOCKCHAIN_HEIGHT:G,MWEB_HEIGHT:U,BC_START_HEIGHT:V,WORKER_ID:j,NUM_WORKERS:z,SYNC_NON_STANDARD:q,ZMQ_WAIT_PERCENTAGE:X,QUERY_LIMIT:Z,LOG_MAX_FILE_SIZE:J,LOG_MAX_FILE_NUM:Q,LOG_ZIP:tt,RPC_URL:et,RPC_BATCHSIZE:nt,RPC_CONCURRENT:st,INDEXDB:at,KEYDB:rt}=process.env;const ot=parseInt(w,10)||"1031";const it=$||"LTC";const ct=S||"regtest";const dt=T||"dev";const lt=R||`http://127.0.0.1:${ot}`;const pt=parseInt(I,10)||1;const mt=N||"bcn";const ut=v||"bcn";const yt=O||"bcn";const ht=b||"127.0.0.1";const gt=parseInt(M,10)||"5432";const ft=C||"http";const wt=H||"bcn-admin";const Et=_||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const $t=A||"node";const St=parseInt(D,10)||19332;g.version;const Tt=parseInt(L,10)||1e4;const Rt=parseInt(Y,10)||500;!F||F.split(",").map((t=>new RegExp(t)));const It=parseInt(V||"",10)||25e5;const Nt=parseInt(j,10)||1;const vt=parseInt(z||"",10)||1;const Ot="true"===q||!1;const bt=parseInt(Z||"",10)||100;const Mt=J||"20m";const Ct=Q||"14d";const Ht=!!tt;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const _t=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const At={zippedArchive:Ht,maxSize:Mt,maxFiles:Ct,dirname:"logs"};const Dt=[];"dev"===dt&&Dt.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),pt>=0&&Dt.push(new p({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...At})),pt>=1&&Dt.push(new p({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...At})),pt>=2&&Dt.push(new p({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...At})),pt>=3&&Dt.push(new p({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...At})),pt>=4&&Dt.push(new p({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...At})),Dt.push(new p({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const xt=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:_t,transports:Dt,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const kt=new m({protocol:ft,user:wt,pass:Et,host:$t,port:St});const Pt=u.promisify(m.prototype.createwallet.bind(kt));const Lt=u.promisify(m.prototype.generateToAddress.bind(kt));const Yt=u.promisify(m.prototype.getaddressinfo.bind(kt));const Bt=u.promisify(m.prototype.getBlock.bind(kt));const Ft=u.promisify(m.prototype.getBlockchainInfo.bind(kt));const Wt=u.promisify(m.prototype.getBlockHash.bind(kt));const Kt=u.promisify(m.prototype.getRawTransaction.bind(kt));const Gt=u.promisify(m.prototype.getRawTransaction.bind(kt));const Ut=u.promisify(m.prototype.getTransaction.bind(kt));const Vt=u.promisify(m.prototype.getNewAddress.bind(kt));const jt={createwallet:Pt,generateToAddress:Lt,getaddressinfo:Yt,getBlock:Bt,getBlockchainInfo:Ft,getBlockHash:Wt,getRawTransaction:Kt,getTransaction:Ut,importaddress:u.promisify(m.prototype.importaddress.bind(kt)),listunspent:u.promisify(m.prototype.listunspent.bind(kt)),sendRawTransaction:u.promisify(m.prototype.sendRawTransaction.bind(kt)),getNewAddress:Vt,sendToAddress:u.promisify(m.prototype.sendToAddress.bind(kt)),getRawTransactionJSON:Gt};const zt={error:(t,e)=>{if(e.cn){const{host:n,port:s,database:a,user:r,password:o}=e.cn;xt.debug(`Waiting for db to start { message:${t.message} host:${n}, port:${s}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===dt&&pt>0&&(h.isAttached()?h.detach():(h.attach(zt),h.setTheme("matrix")));const qt=y(zt)({host:ht,port:gt,database:yt,user:mt,password:ut,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Xt}=y;class Zt{static async select(t){const e=new Xt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "syncedHeight" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return qt.one(e)}static async update({syncedHeight:t,workerId:e}){const n=new Xt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1 WHERE "workerId" = $2',values:[t,e]});await qt.any(n)}static async insert({syncedHeight:t,workerId:e}){const n=new Xt({name:`SyncStatus.insert.${Math.random()}`,text:'INSERT INTO  "SyncStatus"("syncedHeight","workerId") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await qt.any(n)}}class Jt{static async select(t){return Zt.select(t)}static async update(t){await Zt.update(t)}static async insert(t){await Zt.insert(t)}}class Qt{static updateSync=async t=>Jt.update(t);static selectSync=async t=>Jt.select(t);static insertSync=async t=>Jt.insert(t)}function te(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:ee}=y;class ne{static async query(t){const{publicKey:e,hash:n,limit:s,offset:a,order:r,ids:o,mod:i}=t;if(s&&parseInt(s||"",10)>bt||o&&o.length>bt)throw new Error(`Can't fetch more than ${bt} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let c;c=o?.length?'SELECT "rev", "id", array_position($1, "id") as ord\n        FROM "NonStandard" \n        WHERE true ':'SELECT "rev"\n        FROM "NonStandard"\n        WHERE true ';const d=[];n&&(d.push(n),c+=` AND "hash" = $${d.length}`),i&&(d.push(i),c+=` AND "mod" = $${d.length}`),o&&(o.map(te),d.push(o),c+=` AND "id" = ANY ($${d.length})`),e&&(d.push(e),c+=` AND $${d.length} = ANY ("publicKeys")`),r?(c+=` order by "lastUpdated" ${r}`,o?.length&&(c+=", ord")):o?.length&&(c+=" order by ord"),d.push(s||bt),c+=` limit $${d.length}`,a&&(d.push(a),c+=` offset $${d.length}`);const l=new ee({name:`NonStandard.query.${Math.random()}`,text:c,values:d});return(await qt.any(l)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:n,hash:s,mod:a}){const r=new ee({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,n,s,a]});await qt.none(r)}static async update({id:t,rev:e,publicKeys:n}){const s=new ee({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,n]});return qt.none(s)}static async delete({rev:t}){const e=new ee({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await qt.none(e)}static async getRevsByIds(t){if(t&&t.length>bt)throw new Error(`Can't fetch more than ${bt} revs.`);const e=new ee({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return qt.any(e)}static async select(t){const e=new ee({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return qt.oneOrNone(e)}}class se{static async select(t){return ne.select(t)}static async query(t){return ne.query(t)}static async getRevsByIds(t){return ne.getRevsByIds(t)}static async insert(t){return ne.insert(t)}static async update(t){return ne.update(t)}static async delete(t){return ne.delete({rev:t})}}const{PreparedStatement:ae}=y;class re{static async getId(t){const e=new ae({name:`RevToId.select.${Math.random()}`,text:'SELECT "id" FROM "RevToId" WHERE "rev" = $1',values:[t]});const n=await qt.oneOrNone(e);return n?.id}static async insert(t){const e=new ae({name:`RevToId.insert.${Math.random()}`,text:'INSERT INTO "RevToId"("rev", "id") VALUES ($1, $2)  ON CONFLICT DO NOTHING',values:[t.rev,t.id]});await qt.none(e)}}class oe{static async getId(t){return re.getId(t)}static async insert(t){return re.insert(t)}}class ie{static add=async t=>{const{zip:e,outData:n}=t;for(let t=0;t<e.length;t+=1){const[s,a]=e[t];const{exp:o="",_owners:i=[],mod:c=""}=n[t]||{};if(!s&&a)te(a),await se.insert({id:a,rev:a,publicKeys:i,hash:r.sha256(Buffer.from(o)).toString("hex"),mod:c}),await oe.insert({rev:a,id:a});else if(s&&a){const{id:t,hash:e,mod:n}=await se.select(s)||{};await se.update({id:t,rev:a,publicKeys:i,hash:e,mod:n}),await oe.insert({rev:a,id:t})}else s&&!a&&await se.delete(s)}};static query=async t=>se.query(t);static getRevsByIds=async t=>(await se.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:ce}=y;class de{static async select(t){const e=new ce({name:`Input.select.${Math.random()}`,text:'SELECT "rev" FROM "Input" WHERE "rev" = $1',values:[t]});return qt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev]));for(;e.length;){const t=e.splice(0,Tt);const n=[];for(let e=1;e<=t.length;e+=1)n.push(`($${e})`);const s=n.join(",");const a=new ce({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("rev") VALUES ${s} ON CONFLICT DO NOTHING`,values:t});await qt.none(a)}}static async count(t){const e=t.map((t=>t.rev));const n=new ce({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "rev" LIKE ANY ($1)',values:[[e]]});const s=await qt.oneOrNone(n);return parseInt(s?.count,10)||0}}class le{static async select(t){return de.select(t)}static async insert(t){return de.insert(t)}}class pe{static getNonCoinbaseRevs=t=>t.filter((t=>!o.isCoinbaseHash(t.hash))).map((({hash:t,index:e})=>({rev:`${i.reverseBuffer(Buffer.from(t)).toString("hex")}:${e}`})));static insert=async t=>le.insert(this.getNonCoinbaseRevs(t))}const{PreparedStatement:me}=y;class ue{static async select(t){const e=new me({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return qt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys]));for(;e.length;){const t=e.splice(0,Tt);const n=[];for(let e=1;e<=t.length;e+=5)n.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const s=n.join(",");const a=new me({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys") VALUES ${s}  ON CONFLICT DO NOTHING`,values:t});await qt.none(a)}}}class ye{static async select(t){return ue.select(t)}static async insert(t){return ue.insert(t)}}class he{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,n)=>{const{script:s}=e;let a;let r;try{a=c.fromOutputScript(s,f(it,ct))}catch(t){a=null}try{r=d.p2ms({output:s,network:f(it,ct)}).pubkeys.map((t=>t.toString("hex")))}catch(t){r=null}const o=s.toString("hex");const i=Math.round(e.value);return{address:a,rev:`${t.txId}:${n}`,scriptPubKey:o,satoshis:i,publicKeys:r}}))));return ye.insert(e)}}const ge=new e({chain:it,network:ct,url:lt});class fe{static waitForBlock=async e=>{await t((async()=>{xt.info(`Sync workerId ${Nt}: waiting for block ${e} ...`),await jt.getBlockHash(e)}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720}),xt.info(`Node is ready. Starting Sync actions for worker ${Nt}`)};static syncBlock=async t=>{const{result:e}=await jt.getBlockHash(t);const{result:n}=await jt.getBlock(e,2);const{tx:s}=n;const a=s.filter((t=>"08"!==t.hex.slice(10,12)));xt.info(`Backfilling progress ${t} Backfilling ${a.length} transactions (${s.length-a.length} mweb tx's filtered)...`);const r=await Promise.allSettled(a.map((t=>ge.txFromHex({hex:t.hex}))));const o=r.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const i=r.filter((t=>"rejected"===t.status)).map((t=>t.reason));var c,d;i.length&&xt.error(`Failed to parse ${i.length} transactions of block num ${t}: ${i.map((t=>t)).join(", ")}\n        Failed txs: ${c=a.map((t=>t.id)),d=o.map((t=>t.tx.getId())),c.filter((t=>-1===d.indexOf(t)))}`),await this.syncTxs(o,t)};static sync=async(t,e,n,s)=>{try{let a=e;const r=await Qt.selectSync(t);for(r.syncedHeight>e&&(a=r.syncedHeight+n),xt.info(`Starting sync process { initialBlock: ${e} increment: ${n} nonStandard: ${s} syncedHeight:${r.syncedHeight}, currentBlockHeight:${a} }`);s||a<It;)try{await this.syncBlock(a),await Qt.updateSync({syncedHeight:a,workerId:t}),a+=n}catch(t){t.message.includes("out of range")||xt.error(`Syncing block num ${a} failed with error '${t.message}'`)}}catch(t){xt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e)=>{try{await he.insert(t),await pe.insert(t.flatMap((t=>t.tx.ins))),e>=It&&t.map((async t=>{try{t.isBcTx(it,ct)&&await ie.add(t)}catch(e){xt.error(`Failed to add non-standard tx ${t.tx.getId()} ${e.message}`)}}))}catch(t){xt.error(`Processing block ${e} failed with error '${t.message}'`)}};static register=async t=>{try{await Qt.insertSync({syncedHeight:-1,workerId:t}),xt.info(`Register workerId: '${t}'`)}catch(t){xt.error(`Register action failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { nonStandard:${Ot} url: ${lt}, chain:${it} network:${ct} numWorkers: ${vt} workerId: ${Nt} }`;xt.info(e),"regtest"!==ct&&(async()=>{if(await(async()=>{await t((()=>qt.connect()),{startingDelay:Rt})})(),await fe.register(Nt),Ot)await fe.waitForBlock(It),await fe.sync(Nt,It,1,Ot);else{const t=await Qt.selectSync(Nt);const e=t.syncedHeight>0?t.syncedHeight+1:Nt;xt.info(`Worker ${Nt} waiting for block ${e}...`),await fe.waitForBlock(e),xt.info(`Worker ${Nt} starting sync on block ${e}...`),await fe.sync(Nt,e,vt,!1)}})()}catch(t){xt.error(`Synchronizing failed with error '${t.message}'`)}}();
