import{backOff as t}from"exponential-backoff";import{Computer as e}from"@bitcoin-computer/lib";import s from"dotenv";import n from"fs";import{networks as a,bufferUtils as r,crypto as o,Transaction as i,address as c,payments as d}from"@bitcoin-computer/nakamotojs";import p from"winston";import u from"winston-daily-rotate-file";import l from"bitcoind-rpc";import m from"util";import y from"pg-promise";import h from"pg-monitor";s.config();const E=JSON.parse(n.readFileSync("package.json","utf8"));function S(t,e){switch(t){case"BTC":return"mainnet"===e?a.bitcoin:a.testnet;case"LTC":return"mainnet"===e?a.litecoin:a.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}const{PORT:g,ZMQ_URL:f,CHAIN:w,NETWORK:$,BCN_ENV:I,BCN_URL:T,DEBUG_MODE:O,POSTGRES_USER:R,POSTGRES_PASSWORD:N,POSTGRES_DB:v,POSTGRES_HOST:M,POSTGRES_PORT:x,RPC_PROTOCOL:b,RPC_USER:C,RPC_PASSWORD:H,RPC_HOST:A,RPC_PORT:D,SERVER_VERSION:L,DEFAULT_WALLET:_,POSTGRES_MAX_PARAM_NUM:k,DB_CONNECTION_RETRY_TIME:P,SIGNATURE_FRESHNESS_MINUTES:Y,ALLOWED_RPC_METHODS:B,MAX_BLOCKCHAIN_HEIGHT:F,MWEB_HEIGHT:W,BC_START_HEIGHT:U,WORKER_ID:G,NUM_WORKERS:K,SYNC_NON_STANDARD:V,ZMQ_WAIT_PERCENTAGE:j,QUERY_LIMIT:z,LOG_MAX_FILE_SIZE:q,LOG_MAX_FILE_NUM:J,LOG_ZIP:Z}=process.env;const X=parseInt(g,10)||"1031";const Q=w||"LTC";const tt=$||"regtest";const et=I||"dev";const st=T||`http://127.0.0.1:${X}`;const nt=parseInt(O,10)||1;const at=R||"bcn";const rt=N||"bcn";const ot=v||"bcn";const it=M||"127.0.0.1";const ct=parseInt(x,10)||"5432";const dt=b||"http";const pt=C||"bcn-admin";const ut=H||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const lt=A||"node";const mt=parseInt(D,10)||19332;E.version;const yt=parseInt(k,10)||1e4;const ht=parseInt(P,10)||500;!B||B.split(",").map((t=>new RegExp(t)));const Et=parseInt(U||"",10)||25e5;const St=parseInt(G,10)||1;const gt=parseInt(K||"",10)||1;const ft="true"===V||!1;const wt=parseInt(z||"",10)||1e3;const $t=q||"20m";const It=J||"14d";const Tt=!!Z;p.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Ot=p.format.combine(p.format.colorize(),p.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),p.format.json(),p.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Rt={zippedArchive:Tt,maxSize:$t,maxFiles:It,dirname:"logs"};const Nt=[];"dev"===et&&Nt.push(new p.transports.Console({format:p.format.combine(p.format.colorize(),p.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),p.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),nt>=0&&Nt.push(new u({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...Rt})),nt>=1&&Nt.push(new u({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...Rt})),nt>=2&&Nt.push(new u({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...Rt})),nt>=3&&Nt.push(new u({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...Rt})),nt>=4&&Nt.push(new u({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...Rt})),Nt.push(new u({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const vt=p.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Ot,transports:Nt,exceptionHandlers:[new p.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new p.transports.File({filename:"logs/rejections.log"})]});const Mt=new l({protocol:dt,user:pt,pass:ut,host:lt,port:mt});const xt=m.promisify(l.prototype.createwallet.bind(Mt));const bt=m.promisify(l.prototype.generateToAddress.bind(Mt));const Ct=m.promisify(l.prototype.getaddressinfo.bind(Mt));const Ht=m.promisify(l.prototype.getBlock.bind(Mt));const At=m.promisify(l.prototype.getBlockchainInfo.bind(Mt));const Dt=m.promisify(l.prototype.getBlockHash.bind(Mt));const Lt=m.promisify(l.prototype.getRawTransaction.bind(Mt));const _t=m.promisify(l.prototype.getRawTransaction.bind(Mt));const kt=m.promisify(l.prototype.getTransaction.bind(Mt));const Pt=m.promisify(l.prototype.getNewAddress.bind(Mt));const Yt={createwallet:xt,generateToAddress:bt,getaddressinfo:Ct,getBlock:Ht,getBlockchainInfo:At,getBlockHash:Dt,getRawTransaction:Lt,getTransaction:kt,importaddress:m.promisify(l.prototype.importaddress.bind(Mt)),listunspent:m.promisify(l.prototype.listunspent.bind(Mt)),sendRawTransaction:m.promisify(l.prototype.sendRawTransaction.bind(Mt)),getNewAddress:Pt,sendToAddress:m.promisify(l.prototype.sendToAddress.bind(Mt)),getRawTransactionJSON:_t};const Bt={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;vt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===et&&nt>0&&(h.isAttached()?h.detach():(h.attach(Bt),h.setTheme("matrix")));const Ft=y(Bt)({host:it,port:ct,database:ot,user:at,password:rt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Wt}=y;class Ut{static async select(t){const e=new Wt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "syncedHeight" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return Ft.one(e)}static async update({syncedHeight:t,workerId:e}){const s=new Wt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "syncedHeight" = $1 WHERE "workerId" = $2',values:[t,e]});await Ft.any(s)}static async insert({syncedHeight:t,workerId:e}){const s=new Wt({name:`SyncStatus.insert.${Math.random()}`,text:'INSERT INTO  "SyncStatus"("syncedHeight","workerId") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});await Ft.any(s)}}class Gt{static async select(t){return Ut.select(t)}static async update(t){await Ut.update(t)}static async insert(t){await Ut.insert(t)}}class Kt{static updateSync=async t=>Gt.update(t);static selectSync=async t=>Gt.select(t);static insertSync=async t=>Gt.insert(t)}function Vt(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:jt}=y;class zt{static async query(t){const{publicKey:e,hash:s,limit:n,offset:a,order:r,ids:o,mod:i}=t;if(n&&parseInt(n||"",10)>wt||o&&o.length>wt)throw new Error(`Can't fetch more than ${wt} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let c;c=o?.length?'SELECT "rev", "id", array_position($1, "id") as ord\n        FROM "NonStandard" \n        WHERE true ':'SELECT "rev"\n        FROM "NonStandard"\n        WHERE true ';const d=[];s&&(d.push(s),c+=` AND "hash" = $${d.length}`),i&&(d.push(i),c+=` AND "mod" = $${d.length}`),o&&(o.map(Vt),d.push(o),c+=` AND "id" = ANY ($${d.length})`),e&&(d.push(e),c+=` AND $${d.length} = ANY ("publicKeys")`),r?(c+=` order by "lastUpdated" ${r}`,o?.length&&(c+=", ord")):o?.length&&(c+=" order by ord"),d.push(n||wt),c+=` limit $${d.length}`,a&&(d.push(a),c+=` offset $${d.length}`);const p=new jt({name:`NonStandard.query.${Math.random()}`,text:c,values:d});return(await Ft.any(p)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,hash:n,mod:a}){const r=new jt({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,n,a]});await Ft.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new jt({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return Ft.none(n)}static async delete({rev:t}){const e=new jt({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await Ft.none(e)}static async getRevsByIds(t){if(t&&t.length>wt)throw new Error(`Can't fetch more than ${wt} revs.`);const e=new jt({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return Ft.any(e)}static async select(t){const e=new jt({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return Ft.oneOrNone(e)}}class qt{static async select(t){return zt.select(t)}static async query(t){return zt.query(t)}static async getRevsByIds(t){return zt.getRevsByIds(t)}static async insert(t){return zt.insert(t)}static async update(t){return zt.update(t)}static async delete(t){return zt.delete({rev:t})}}const{PreparedStatement:Jt}=y;class Zt{static async getId(t){const e=new Jt({name:`RevToId.select.${Math.random()}`,text:'SELECT "id" FROM "RevToId" WHERE "rev" = $1',values:[t]});const s=await Ft.oneOrNone(e);return s?.id}static async insert(t){const e=new Jt({name:`RevToId.insert.${Math.random()}`,text:'INSERT INTO "RevToId"("rev", "id") VALUES ($1, $2)  ON CONFLICT DO NOTHING',values:[t.rev,t.id]});await Ft.none(e)}}class Xt{static async getId(t){return Zt.getId(t)}static async insert(t){return Zt.insert(t)}}class Qt{static add=async t=>{const{zip:e,outData:s}=t;for(let t=0;t<e.length;t+=1){const[n,a]=e[t];const{exp:r="",_owners:i=[],mod:c=""}=s[t]||{};if(!n&&a)Vt(a),await qt.insert({id:a,rev:a,publicKeys:i,hash:o.sha256(Buffer.from(r)).toString("hex"),mod:c}),await Xt.insert({rev:a,id:a});else if(n&&a){const{id:t,hash:e,mod:s}=await qt.select(n)||{};await qt.update({id:t,rev:a,publicKeys:i,hash:e,mod:s}),await Xt.insert({rev:a,id:t})}else n&&!a&&await qt.delete(n)}};static query=async t=>qt.query(t);static getRevsByIds=async t=>(await qt.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:te}=y;class ee{static async select(t){const e=new te({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return Ft.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,yt);const s=[];for(let e=1;e<=t.length;e+=2)s.push(`($${e}, $${e+1})`);const n=s.join(",");const a=new te({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await Ft.none(a)}}static async count(t){const e=t.map((t=>t.outputSpent));const s=new te({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const n=await Ft.oneOrNone(s);return parseInt(n?.count,10)||0}}class se{static async select(t){return ee.select(t)}static async insert(t){return ee.insert(t)}}class ne{static getNonCoinbaseRevs=t=>t.filter((t=>!i.isCoinbaseHash(t.input.hash))).map((({input:t,txId:e},s)=>{return{outputSpent:`${n=t.hash,r.reverseBuffer(Buffer.from(n)).toString("hex")}:${t.index}`,spendingInput:`${e}:${s}`};var n}));static insert=async t=>{se.insert(this.getNonCoinbaseRevs(t))}}const{PreparedStatement:ae}=y;class re{static async listSentOutputs(t){const e=new ae({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await Ft.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new ae({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await Ft.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new ae({name:`Output.listTxs.${Math.random()}`,text:' -- List all txs sent from a given address\n            WITH SENT AS (\n              SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n              FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n              WHERE "Output".address = $1\n              GROUP BY split_part("Input"."spendingInput",\':\',1)\n            )\n            \n            -- List all tx received from a given address\n            , RECEIVED AS (\n              SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n              FROM "Output" \n              WHERE "address" = $1\n              GROUP BY "txId"\n            )\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n                SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId" ;',values:[t]});const s=(await Ft.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new ae({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return Ft.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys]));for(;e.length;){const t=e.splice(0,yt);const s=[];for(let e=1;e<=t.length;e+=5)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const n=s.join(",");const a=new ae({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await Ft.none(a)}}}class oe{static async select(t){return re.select(t)}static async insert(t){return re.insert(t)}static async listSentOutputs(t){return re.listSentOutputs(t)}static async listReceivedOutputs(t){return re.listReceivedOutputs(t)}static async listTxs(t){return re.listTxs(t)}}class ie{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,s)=>{const{script:n}=e;let a;let r;try{a=c.fromOutputScript(n,S(Q,tt))}catch(t){a=null}try{r=d.p2ms({output:n,network:S(Q,tt)}).pubkeys.map((t=>t.toString("hex")))}catch(t){r=null}const o=n.toString("hex");const i=Math.round(e.value);return{address:a,rev:`${t.txId}:${s}`,scriptPubKey:o,satoshis:i,publicKeys:r}}))));return oe.insert(e)};static listSentOutputs=async t=>oe.listSentOutputs(t);static listReceivedOutputs=async t=>oe.listReceivedOutputs(t);static listTxs=async t=>oe.listTxs(t)}const ce=new e({chain:Q,network:tt,url:st});class de{static waitForBlock=async e=>{await t((async()=>{vt.info(`Sync workerId ${St}: waiting for block ${e} ...`),await Yt.getBlockHash(e)}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720}),vt.info(`Node is ready. Starting Sync actions for worker ${St}`)};static syncBlock=async(t,e="LTC")=>{const{result:s}=await Yt.getBlockHash(t);const{result:n}=await Yt.getBlock(s,2);const{tx:a}=n;let r=a;"LTC"===e&&(r=a.filter((t=>"08"!==t.hex.slice(10,12))));const o=`Backfilling progress ${t} Backfilling ${r.length} txs `;"LTC"===e&&o.concat(`(${a.length-r.length} mweb tx's filtered)...`),vt.info(o);const i=await Promise.allSettled(r.map((t=>ce.txFromHex({hex:t.hex}))));const c=i.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const d=i.filter((t=>"rejected"===t.status)).map((t=>t.reason));var p,u;d.length&&vt.error(`Failed to parse ${d.length} transactions of block num ${t}: ${d.map((t=>t)).join(", ")}\n        Failed txs: ${p=r.map((t=>t.id)),u=c.map((t=>t.tx.getId())),p.filter((t=>-1===u.indexOf(t)))}`),await this.syncTxs(c,t)};static sync=async(t,e,s,n)=>{try{let a=e;const r=await Kt.selectSync(t);for(r.syncedHeight>e&&(a=r.syncedHeight+s),vt.info(`Starting sync process { initialBlock: ${e} increment: ${s} nonStandard: ${n} syncedHeight:${r.syncedHeight}, currentBlockHeight:${a} }`);n||a<Et;)try{await this.syncBlock(a,Q),await Kt.updateSync({syncedHeight:a,workerId:t}),a+=s}catch(t){t.message.includes("out of range")||vt.error(`Syncing block num ${a} failed with error '${t.message}'`)}}catch(t){vt.error(`Sync action failed with error '${t.message}'`)}};static syncTxs=async(t,e)=>{try{await ie.insert(t),await ne.insert(t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId})))))),e>=Et&&t.map((async t=>{try{t.isBcTx(Q,tt)&&await Qt.add(t)}catch(e){vt.error(`Failed to add non-standard tx ${t.tx.getId()} ${e.message}`)}}))}catch(t){vt.error(`Processing block ${e} failed with error '${t.message}'`)}};static register=async t=>{try{await Kt.insertSync({syncedHeight:-1,workerId:t}),vt.info(`Register workerId: '${t}'`)}catch(t){vt.error(`Register action failed with error '${t.message}'`)}}}!function(){try{const e=`Synchronizing { nonStandard:${ft} url: ${st}, chain:${Q} network:${tt} numWorkers: ${gt} workerId: ${St} }`;vt.info(e),"regtest"!==tt&&(async()=>{if(await(async()=>{await t((()=>Ft.connect()),{startingDelay:ht})})(),await de.register(St),ft)await de.waitForBlock(Et),await de.sync(St,Et,1,ft);else{const t=await Kt.selectSync(St);const e=t.syncedHeight>0?t.syncedHeight+1:St;vt.info(`Worker ${St} waiting for block ${e}...`),await de.waitForBlock(e),vt.info(`Worker ${St} starting sync on block ${e}...`),await de.sync(St,e,gt,!1)}})()}catch(t){vt.error(`Synchronizing failed with error '${t.message}'`)}}();
