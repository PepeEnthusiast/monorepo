import*as t from"@bitcoin-computer/tiny-secp256k1";import{bufferUtils as e,networks as s,crypto as n,Transaction as a,address as r,payments as o,initEccLib as c}from"@bitcoin-computer/nakamotojs";import{backOff as i}from"exponential-backoff";import{Computer as p}from"@bitcoin-computer/lib";import u from"dotenv";import d from"fs";import l from"winston";import m from"winston-daily-rotate-file";import h from"bitcoind-rpc";import y from"util";import S from"pg-promise";import w from"pg-monitor";u.config();const E=process.env.CHAIN;const f=process.env.NETWORK;const{PORT:$}=process.env;const{POSTGRES_USER:g}=process.env;const{POSTGRES_PASSWORD:v}=process.env;const{POSTGRES_DB:I}=process.env;const{POSTGRES_HOST:O}=process.env;const{POSTGRES_PORT:T}=process.env;const{RPC_USER:R}=process.env;const{RPC_PASSWORD:N}=process.env;process.env;const{RPC_HOST:x}=process.env;const{RPC_PORT:b}=process.env;const{RPC_PROTOCOL:M}=process.env;process.env,process.env,process.env;const{DEBUG_MODE:k}=process.env;const{LOG_MAX_FILES:C}=process.env;const{LOG_MAX_SIZE:D}=process.env;const{LOG_ZIP:A}=process.env;process.env;const L=process.env.QUERY_LIMIT||"1000";const H=process.env.WORKER_ID||"1";const P="true"===process.env.SYNC_NON_STANDARD||!1;const Y=process.env.NUM_WORKERS||"1";const B=process.env.BCN_URL||`http://127.0.0.1:${$}`;const F=process.env.BCN_ENV||"dev";u.config();const{version:_}=JSON.parse(d.readFileSync("package.json","utf8"));_||process.env.SERVER_VERSION,parseInt(process.env.MWEB_HEIGHT||"",10);const W=3211111;l.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const U=l.format.combine(l.format.colorize(),l.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),l.format.json(),l.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const K={zippedArchive:!!A,maxSize:D,maxFiles:C,dirname:"logs"};const G=[];"dev"===F&&G.push(new l.transports.Console({format:l.format.combine(l.format.colorize(),l.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),l.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))}));const V=parseInt(k,10);V>=0&&G.push(new m({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...K})),V>=1&&G.push(new m({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...K})),V>=2&&G.push(new m({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...K})),V>=3&&G.push(new m({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...K})),V>=4&&G.push(new m({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...K}));const j=l.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:U,transports:G,exceptionHandlers:[new l.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new l.transports.File({filename:"logs/rejections.log"})]});const z=new h({protocol:M,user:R,pass:N,host:x,port:parseInt(b,10)});const q=y.promisify(h.prototype.createwallet.bind(z));const J=y.promisify(h.prototype.generateToAddress.bind(z));const X=y.promisify(h.prototype.getaddressinfo.bind(z));const Z=y.promisify(h.prototype.getBlock.bind(z));const Q=y.promisify(h.prototype.getBlockchainInfo.bind(z));const tt=y.promisify(h.prototype.getBlockHash.bind(z));const et=y.promisify(h.prototype.getRawTransaction.bind(z));const st=y.promisify(h.prototype.getRawTransaction.bind(z));const nt=y.promisify(h.prototype.getTransaction.bind(z));const at=y.promisify(h.prototype.getNewAddress.bind(z));const rt={createwallet:q,generateToAddress:J,getaddressinfo:X,getBlock:Z,getBlockchainInfo:Q,getBlockHash:tt,getRawTransaction:et,getTransaction:nt,importaddress:y.promisify(h.prototype.importaddress.bind(z)),listunspent:y.promisify(h.prototype.listunspent.bind(z)),sendRawTransaction:y.promisify(h.prototype.sendRawTransaction.bind(z)),getNewAddress:at,sendToAddress:y.promisify(h.prototype.sendToAddress.bind(z)),getRawTransactionJSON:st};function ot(t=E,e=f){switch(t){case"BTC":switch(e){case"mainnet":return s.bitcoin;case"testnet":return s.testnet;case"regtest":return s.regtest;default:throw new Error(`Invalid network ${e}`)}case"LTC":switch(e){case"mainnet":return s.litecoin;case"testnet":return s.litecointestnet;case"regtest":return s.litecoinregtest;default:throw new Error(`Invalid network ${e}`)}default:throw new Error(`Invalid chain ${e}`)}}const ct={error:(t,e)=>{if(e.cn){const{host:s,port:n,database:a,user:r,password:o}=e.cn;j.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${n}, database:${a}, user:${r}, password: ${o}`)}},noWarnings:!0};"dev"===F&&parseInt(k,10)>0&&(w.isAttached()?w.detach():(w.attach(ct),w.setTheme("matrix")));const it=S(ct)({host:O,port:parseInt(T,10),database:I,user:g,password:v,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:pt}=S;class ut{static async select(t){const e=new pt({name:`SyncStatus.select.${Math.random()}`,text:'SELECT "blockToSync", "nonStandard", "workerId" FROM "SyncStatus" WHERE "workerId" = $1',values:[t]});return it.oneOrNone(e)}static async update({blockToSync:t,workerId:e}){const s=new pt({name:`SyncStatus.update.${Math.random()}`,text:'UPDATE "SyncStatus" SET "blockToSync" = $1 WHERE "workerId" = $2',values:[t,e]});await it.any(s)}static async count(){const t=new pt({name:`SyncStatus.count.${Math.random()}`,text:'SELECT COUNT(*) FROM "SyncStatus"'});const e=await it.oneOrNone(t);return parseInt(e?.count,10)||0}static async min(t){const e=new pt({name:`SyncStatus.min.${Math.random()}`,text:'SELECT MIN("blockToSync") FROM "SyncStatus" where "nonStandard" = $1',values:[t]});const s=await it.oneOrNone(e);return parseInt(s?.min,10)||0}static async delete(){const t=new pt({name:`SyncStatus.delete.${Math.random()}`,text:'DELETE FROM "SyncStatus"'});await it.any(t)}static async insertBatch(t){const e=[];for(let s=1;s<=t.length;s+=3)e.push(`($${s}, $${s+1}, $${s+2})`);const s=e.join(",");const n=new pt({name:`SyncStatus.reorg.${Math.random()}`,text:`INSERT INTO "SyncStatus"("workerId", "blockToSync", "nonStandard") VALUES ${s}`,values:t});await it.any(n)}}class dt{static async select(t){return ut.select(t)}static async update(t){await ut.update(t)}static async count(){return ut.count()}static async insertBatch(t){await ut.insertBatch(t)}static async minStandard(){return ut.min(!1)}static async minNonStandard(){return ut.min(!0)}static async delete(){await ut.delete()}}class lt{static update=async t=>dt.update(t);static select=async t=>dt.select(t);static setup=async t=>{if(await dt.count()===t)return;const e=[];const s=Math.max(W,await dt.minNonStandard());let n=Math.max(1,await dt.minStandard());for(let s=1;s<t;s+=1,n+=1)e.push(s,n,!1);e.push(t,s,!0),await dt.delete(),await dt.insertBatch(e)};static waitUntilSetup=async t=>{i((async()=>{if(await dt.count()===t)return!0;throw new Error("Not all workers have reorged")}),{startingDelay:500})}}function mt(t){if(!function(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}(t))throw new Error("Invalid rev")}const{PreparedStatement:ht}=S;class yt{static async query(t){const{publicKey:e,hash:s,limit:n,offset:a,order:r,ids:o,mod:c}=t;const i=parseInt(L,10);if(n&&parseInt(n||"",10)>i||o&&o.length>i)throw new Error(`Can't fetch more than ${L} revs.`);if(r&&"ASC"!==r&&"DESC"!==r)throw new Error("Invalid order");let p;p=o?.length?'SELECT "rev", "id", array_position($1, "id") as ord\n        FROM "NonStandard" \n        WHERE true ':'SELECT "rev"\n        FROM "NonStandard"\n        WHERE true ';const u=[];o&&(o.map(mt),u.push(o),p+=` AND "id" = ANY ($${u.length})`),s&&(u.push(s),p+=` AND "hash" = $${u.length}`),c&&(u.push(c),p+=` AND "mod" = $${u.length}`),e&&(u.push(e),p+=` AND $${u.length} = ANY ("publicKeys")`),r?(p+=` order by "lastUpdated" ${r}`,o?.length&&(p+=", ord")):o?.length&&(p+=" order by ord"),u.push(n||i),p+=` limit $${u.length}`,a&&(u.push(a),p+=` offset $${u.length}`);const d=new ht({name:`NonStandard.query.${Math.random()}`,text:p,values:u});const l=await it.any(d);const m=l.map((t=>t.rev));if(o?.length&&l.length!==o.length){const t={};return l.forEach((e=>{t[e.id]=e.rev})),o?.map((e=>t[e]??null))??[]}return m}static async insert({id:t,rev:e,publicKeys:s,hash:n,mod:a}){const r=new ht({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,n,a]});await it.none(r)}static async update({id:t,rev:e,publicKeys:s}){const n=new ht({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return it.none(n)}static async delete({rev:t}){const e=new ht({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await it.none(e)}static async getRevsByIds(t){const e=parseInt(L,10);if(t&&t.length>e)throw new Error(`Can't fetch more than ${L} revs.`);const s=new ht({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return it.any(s)}static async select(t){const e=new ht({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return it.oneOrNone(e)}}class St{static async select(t){return yt.select(t)}static async query(t){return yt.query(t)}static async getRevsByIds(t){return yt.getRevsByIds(t)}static async insert(t){return yt.insert(t)}static async update(t){return yt.update(t)}static async delete(t){return yt.delete({rev:t})}}const{PreparedStatement:wt}=S;class Et{static async getId(t){const e=new wt({name:`RevToId.select.${Math.random()}`,text:'SELECT "id" FROM "RevToId" WHERE "rev" = $1',values:[t]});const s=await it.oneOrNone(e);return s?.id}static async insert(t){const e=new wt({name:`RevToId.insert.${Math.random()}`,text:'INSERT INTO "RevToId"("rev", "id") VALUES ($1, $2)  ON CONFLICT DO NOTHING',values:[t.rev,t.id]});await it.none(e)}}class ft{static async getId(t){return Et.getId(t)}static async insert(t){return Et.insert(t)}}class $t{static add=async t=>{let e;let s;try{({zip:e,outData:s}=t)}catch{return}for(let t=0;t<e.length;t+=1){const[a,r]=e[t];const{exp:o="",_owners:c=[],mod:i=""}=s[t]||{};if(!a&&r)mt(r),await St.insert({id:r,rev:r,publicKeys:c,hash:n.sha256(Buffer.from(o)).toString("hex"),mod:i}),await ft.insert({rev:r,id:r});else if(a&&r){const{id:t,hash:e,mod:s}=await St.select(a)||{};await St.update({id:t,rev:r,publicKeys:c,hash:e,mod:s}),await ft.insert({rev:r,id:t})}else a&&!r&&await St.delete(a)}};static query=async t=>St.query(t);static getRevsByIds=async t=>(await St.getRevsByIds(t)).map((t=>t.rev))}const{PreparedStatement:gt}=S;class vt{static async select(t){const e=new gt({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return it.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,1e4);const s=[];for(let e=1;e<=t.length;e+=2)s.push(`($${e}, $${e+1})`);const n=s.join(",");const a=new gt({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${n} ON CONFLICT DO NOTHING`,values:t});await it.none(a)}}static async count(t){const e=t.map((t=>t.outputSpent));const s=new gt({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const n=await it.oneOrNone(s);return parseInt(n?.count,10)||0}}class It{static async select(t){return vt.select(t)}static async insert(t){return vt.insert(t)}}class Ot{static getNonCoinbaseRevs=t=>t.filter((t=>!a.isCoinbaseHash(t.input.hash))).map((({input:t,txId:s},n)=>{return{outputSpent:`${a=t.hash,e.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${s}:${n}`};var a}));static insert=async t=>{const e=t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId})))));It.insert(this.getNonCoinbaseRevs(e))}}const{PreparedStatement:Tt}=S;class Rt{static async listSentOutputs(t){const e=new Tt({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await it.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new Tt({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await it.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new Tt({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await it.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new Tt({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return it.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys]));for(;e.length;){const t=e.splice(0,1e4);const s=[];for(let e=1;e<=t.length;e+=5)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const n=s.join(",");const a=new Tt({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys") VALUES ${n}  ON CONFLICT DO NOTHING`,values:t});await it.none(a)}}}class Nt{static async select(t){return Rt.select(t)}static async insert(t){return Rt.insert(t)}static async listSentOutputs(t){return Rt.listSentOutputs(t)}static async listReceivedOutputs(t){return Rt.listReceivedOutputs(t)}static async listTxs(t){return Rt.listTxs(t)}}class xt{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,s)=>{const{script:n}=e;let a;let c;try{a=r.fromOutputScript(n,ot(E,f))}catch(t){a=null}try{c=o.p2ms({output:n,network:ot(E,f)}).pubkeys.map((t=>t.toString("hex"))),c.some((t=>t.length>66))&&(c=null)}catch(t){c=null}const i=n.toString("hex");const p=Math.round(e.value);return{address:a,rev:`${t.txId}:${s}`,scriptPubKey:i,satoshis:p,publicKeys:c}}))));return Nt.insert(e)};static listSentOutputs=async t=>Nt.listSentOutputs(t);static listReceivedOutputs=async t=>Nt.listReceivedOutputs(t);static listTxs=async t=>Nt.listTxs(t)}const bt=new p({chain:E,network:f,url:B});class Mt{static waitForBlockHash=async t=>(await i((async()=>{let e;try{e=await rt.getBlockHash(t)}catch(e){throw j.info(`Sync workerId ${H}: waiting for block ${t} ...`),e}return e}),{startingDelay:3e4,timeMultiple:1,numOfAttempts:720})).result;static syncBlock=async(t,e="LTC")=>{const s=await Mt.waitForBlockHash(t);const{result:n}=await rt.getBlock(s,2);const{tx:a}=n;let r=a;"LTC"===e&&(r=a.filter((t=>"08"!==t.hex.slice(10,12))));const o=`Backfilling progress ${t} Backfilling ${r.length} txs `;"LTC"===e&&o.concat(`(${a.length-r.length} mweb tx's filtered)...`),j.info(o);const c=await Promise.allSettled(r.map((t=>bt.txFromHex({hex:t.hex}))));const i=c.filter((t=>"fulfilled"===t.status)).map((t=>t.value));const p=c.filter((t=>"rejected"===t.status)).map((t=>t.reason));var u,d;p.length&&j.error(`Failed to parse ${p.length} transactions of block num ${t}: ${p.map((t=>t)).join(", ")}\n        Failed txs: ${u=r.map((t=>t.id)),d=i.map((t=>t.tx.getId())),u.filter((t=>-1===d.indexOf(t)))}`),await this.syncTxs(i,t)};static sync=async(t,e,s,n,a)=>{for(;n||e<a;){try{await this.syncBlock(e,E)}catch(t){j.error(`Syncing block num ${e} failed with error '${t.message}'`)}e+=s,await lt.update({blockToSync:e,workerId:t})}j.info(`Sync workerId ${t} finished syncing up to block ${e}`)};static syncTxs=async(t,e)=>{try{await xt.insert(t),await Ot.insert(t),e>=W&&t.map((async t=>{try{await $t.add(t)}catch(e){j.error(`Failed to add non-standard tx ${t.tx.getId()} ${e.message}`)}}))}catch(t){j.error(`Processing block ${e} failed with error '${t.message}'`)}}}c(t),function(){try{const t=`Synchronizing { nonStandard:${P} url: ${B}, chain:${E} network:${f} numWorkers: ${Y} workerId: ${H} activationHeight: 3211111 }`;j.info(t),"regtest"!==f&&(async()=>{const t=parseInt(Y,10);const e=t-1;if(await(async()=>{await i((()=>it.connect()),{startingDelay:500})})(),j.info(`Worker ${H} connected to the database successfully. Setting up syncStatus table...`),t<2)throw new Error(`At least two workers are needed to sync the blockchain. Please check the configuration. ${Y} workers are configured.`);1===parseInt(H,10)?await lt.setup(t):await lt.waitUntilSetup(t);const s=await lt.select(parseInt(H,10));const n=s.nonStandard?1:e;j.info(`WorkerId ${s.workerId} starting sync on blockToSync: ${s.blockToSync} - \n     increment: ${n} - sycNonStandard: ${s.nonStandard} - numWorkers: ${Y} - num standard workers: ${e}`),await Mt.sync(s.workerId,s.blockToSync,n,s.nonStandard,W)})()}catch(t){j.error(`Synchronizing failed with error '${t.message}'`)}}();
