import t from"body-parser";import e from"cors";import s from"express";import r from"http";import*as a from"zeromq";import n from"express-rate-limit";import*as o from"@bitcoin-computer/tiny-secp256k1";import{networks as i,bufferUtils as c,crypto as u,address as l,payments as p,Psbt as d,Transaction as m,initEccLib as h}from"@bitcoin-computer/nakamotojs";import y from"dotenv";import g from"fs";import w from"winston";import f from"winston-daily-rotate-file";import E from"pg-promise";import v from"pg-monitor";import{backOff as T}from"exponential-backoff";import{ECPairFactory as $}from"ecpair";import S from"bitcoind-rpc";import O from"util";import{Computer as R}from"@bitcoin-computer/lib";import b from"elliptic";import I from"hash.js";import x,{dirname as N}from"path";import{fileURLToPath as M}from"url";y.config();const C=JSON.parse(g.readFileSync("package.json","utf8"));const{PORT:P,ZMQ_URL:A,CHAIN:L,NETWORK:B,BCN_ENV:j,BCN_URL:H,DEBUG_MODE:U,POSTGRES_USER:_,POSTGRES_PASSWORD:k,POSTGRES_DB:F,POSTGRES_HOST:K,POSTGRES_PORT:D,RPC_PROTOCOL:W,RPC_USER:Y,RPC_PASSWORD:G,RPC_HOST:q,RPC_PORT:J,SERVER_VERSION:V,DEFAULT_WALLET:z,POSTGRES_MAX_PARAM_NUM:Z,DB_CONNECTION_RETRY_TIME:Q,SIGNATURE_FRESHNESS_MINUTES:X,ALLOWED_RPC_METHODS:tt,MAX_BLOCKCHAIN_HEIGHT:et,MWEB_HEIGHT:st,WORKER_ID:rt,NUM_WORKERS:at,ZMQ_WAIT_PERCENTAGE:nt,QUERY_LIMIT:ot,LOG_MAX_FILE_SIZE:it,LOG_MAX_FILE_NUM:ct,LOG_ZIP:ut}=process.env;const lt=parseInt(P,10)||"1031";const pt=A||"tcp://node:28332";const dt=L||"LTC";const mt=B||"regtest";const ht=j||"dev";const yt=H||`http://127.0.0.1:${lt}`;const gt=parseInt(U,10)||1;const wt=_||"bcn";const ft=k||"bcn";const Et=F||"bcn";const vt=K||"127.0.0.1";const Tt=parseInt(D,10)||"5432";const $t=W||"http";const St=Y||"bcn-admin";const Ot=G||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const Rt=q||"node";const bt=parseInt(J,10)||19332;const It=C.version||V;const xt=z||"defaultwallet";const Nt=parseInt(Z,10)||1e4;const Mt=parseInt(Q,10)||500;const Ct=parseInt(X,10)||3;const Pt=tt?tt.split(",").map((t=>new RegExp(t))):[];const At=parseInt(et||"",10)||2538171;const Lt=parseInt(st||"",10)||432;const Bt=parseInt(rt,10)||1;const jt=parseInt(nt||"",10)||.7;const Ht=parseInt(ot||"",10)||1e3;const Ut=it||"20m";const _t=ct||"14d";const kt=!!ut;w.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Ft=w.format.combine(w.format.colorize(),w.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),w.format.json(),w.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Kt={zippedArchive:kt,maxSize:Ut,maxFiles:_t,dirname:"logs"};const Dt=[];"dev"===ht&&Dt.push(new w.transports.Console({format:w.format.combine(w.format.colorize(),w.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),w.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),gt>=0&&Dt.push(new f({filename:`error${Bt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"error",...Kt})),gt>=1&&Dt.push(new f({filename:`warn${Bt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"warn",...Kt})),gt>=2&&Dt.push(new f({filename:`info${Bt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"info",...Kt})),gt>=3&&Dt.push(new f({filename:`http${Bt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"http",...Kt})),gt>=4&&Dt.push(new f({filename:`debug${Bt}%-%DATE%.log`,datePattern:"YYYY-MM-DD",level:"debug",...Kt}));const Wt=w.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Ft,transports:Dt,exceptionHandlers:[new w.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new w.transports.File({filename:"logs/rejections.log"})]});const Yt=()=>"dev"===ht;const Gt={error:(t,e)=>{if(e.cn){const{host:s,port:r,database:a,user:n,password:o}=e.cn;Wt.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${r}, database:${a}, user:${n}, password: ${o}`)}},noWarnings:!0};Yt()&&gt>0&&(v.isAttached()?v.detach():(v.attach(Gt),v.setTheme("matrix")));const qt=E(Gt)({host:vt,port:Tt,database:Et,user:wt,password:ft,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:Jt}=E;class Vt{static async select(t){const e=new Jt({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return qt.oneOrNone(e)}static async insert({id:t,data:e}){const s=new Jt({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return qt.none(s)}static async delete(t){const e=new Jt({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await qt.any(e))[0].count>0}}class zt{static async select(t){const e=await Vt.select(t);return e?.data||null}static async insert(t){return Vt.insert(t)}static async delete(t){return Vt.delete(t)}}const Zt=s.Router();Zt.get("/:id",(async({params:{id:t},url:e},s)=>{try{const e=await zt.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),Zt.post("/",(async(t,e)=>{const{body:{data:s},url:r}=t;try{const r=u.sha256(Buffer.from(s)).toString("hex");await zt.insert({id:r,data:s});const a=`${t.protocol}://${t.get("host")}/store/${r}`;e.status(201).json({_url:a})}catch(t){Wt.error(`POST ${r} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),Zt.delete("/:id",(async(t,e)=>{e.status(500).json({error:"Deletions are not supported yet."})}));const{PreparedStatement:Qt}=E;class Xt{static async getBalance(t){const e=new Qt({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT sum("satoshis") as "satoshis" FROM "Utxos" WHERE "address" = $1',values:[t]});const s=await qt.oneOrNone(e);return parseInt(s?.satoshis,10)||0}static async select(t){const e=new Qt({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "address" = $1',values:[t]});return(await qt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByScriptHex(t){const e=new Qt({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "scriptPubKey" = $1',values:[t]});return(await qt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByPk(t){const e=new Qt({name:`Utxos.selectByPk.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout", "publicKeys" FROM "Utxos" WHERE $1 = ANY ("publicKeys")',values:[t]});return(await qt.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}}class te{static async getBalance(t){return Xt.getBalance(t)}static async select(t){return Xt.select(t)}static async selectByScriptHex(t){return Xt.selectByScriptHex(t)}static async selectByPk(t){return Xt.selectByPk(t)}}class ee{static getBalance=async t=>te.getBalance(t);static select=async t=>te.select(t);static selectByScriptHex=async t=>te.selectByScriptHex(t);static selectByPk=async t=>te.selectByPk(t)}const se=new S({protocol:$t,user:St,pass:Ot,host:Rt,port:bt});const re=O.promisify(S.prototype.createwallet.bind(se));const ae=O.promisify(S.prototype.generateToAddress.bind(se));const ne=O.promisify(S.prototype.getaddressinfo.bind(se));const oe=O.promisify(S.prototype.getBlock.bind(se));const ie=O.promisify(S.prototype.getBlockchainInfo.bind(se));const ce=O.promisify(S.prototype.getBlockHash.bind(se));const ue=O.promisify(S.prototype.getRawTransaction.bind(se));const le=O.promisify(S.prototype.getRawTransaction.bind(se));const pe=O.promisify(S.prototype.getTransaction.bind(se));const de=O.promisify(S.prototype.getNewAddress.bind(se));const me={createwallet:re,generateToAddress:ae,getaddressinfo:ne,getBlock:oe,getBlockchainInfo:ie,getBlockHash:ce,getRawTransaction:ue,getTransaction:pe,importaddress:O.promisify(S.prototype.importaddress.bind(se)),listunspent:O.promisify(S.prototype.listunspent.bind(se)),sendRawTransaction:O.promisify(S.prototype.sendRawTransaction.bind(se)),getNewAddress:de,sendToAddress:O.promisify(S.prototype.sendToAddress.bind(se)),getRawTransactionJSON:le};class he{static async getTransaction(t){const{result:e}=await me.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>me.getRawTransaction(t))))).map((t=>t.result))}static async getRawTransactionsJSON(t){return{txId:(e=(await me.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence})),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await me.sendRawTransaction(t);if(s)throw Wt.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await me.getaddressinfo(t)).result.timestamp&&(Wt.info(`Importing address: ${t}`),await me.importaddress(t,!1)),(await me.listunspent(0,999999,[t])).result)}class ye{static get=async t=>he.getTransaction(t);static getRaw=async t=>he.getBulkTransactions(t);static getRawJSON=async t=>he.getRawTransactionsJSON(t);static sendRaw=async t=>he.sendRawTransaction(t);static getUtxos=async t=>he.getUtxos(t)}const ge=new S({protocol:$t,user:St,pass:Ot,host:Rt,port:bt});const we={};const fe=JSON.parse(JSON.stringify(S.callspec));Object.keys(fe).forEach((t=>{fe[t.toLowerCase()]=fe[t]}));const Ee={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys(S.prototype).forEach((t=>{if(t&&"function"==typeof S.prototype[t]){const e=t.toLowerCase();we[t]=O.promisify(S.prototype[t].bind(ge)),we[e]=O.promisify(S.prototype[e].bind(ge))}}))}catch(t){Wt.error(`Error occurred while binding RPC methods: ${t.message}`)}function ve(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}function Te(t){if(!ve(t))throw new Error("Invalid rev")}const{PreparedStatement:$e}=E;class Se{static async listSentOutputs(t){const e=new $e({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await qt.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new $e({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await qt.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new $e({name:`Output.listTxs.${Math.random()}`,text:'WITH\n              -- List all txs sent from a given address\n              SENT AS (\n                SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n                FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n                WHERE "Output".address = $1\n                GROUP BY split_part("Input"."spendingInput",\':\',1)\n              ),\n              -- List all tx received from a given address\n              RECEIVED AS (\n                SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n                FROM "Output" \n                WHERE "address" = $1\n                GROUP BY "txId"\n              )\n\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n              SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId";',values:[t]});const s=(await qt.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new $e({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", "publicKeys", "hash", "mod", "isTbcOutput", "previous" FROM "Output" WHERE "address" = $1',values:[t]});return qt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys,t.hash,t.mod,t.isTbcOutput,t.previous]));for(;e.length;){const t=e.splice(0,Nt);const s=[];for(let e=1;e<=t.length;e+=9)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4}, $${e+5}, $${e+6}, $${e+7}, $${e+8})`);const r=s.join(",");const a=new $e({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys", "hash", "mod", "isTbcOutput", "previous") VALUES ${r}  ON CONFLICT DO NOTHING`,values:t});await qt.none(a)}}static async getIdByRev(t){const e=new $e({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON r."previous" = o."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=(await qt.any(e)).filter((t=>null===t.previous));return s[0]?.rev}static async getIdsByRevs(t){return Promise.all(t.map((t=>this.getIdByRev(t))))}static async getLatestRev(t){const e=new $e({name:`NonStandard.recursiveUpdates.${Math.random()}`,text:'WITH RECURSIVE revUpdates AS (\n        SELECT "rev", "previous" FROM "Output" WHERE "isTbcOutput" = true and "rev" = $1\n        UNION ALL\n        SELECT o."rev", o."previous" FROM "Output" o\n        INNER JOIN revUpdates r ON o."previous" = r."rev"\n      )\n      SELECT * FROM revUpdates',values:[t]});const s=await qt.any(e);const r=Object.fromEntries(s.map((t=>[t.previous,t.rev])));let a=t;for(;r[a];)a=r[a];return a}static async getLatestRevs(t){return Promise.all(t.map(this.getLatestRev))}static async getIdsByMod(t){const e=new $e({name:`Output.getIdsByMod.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1',values:[t]});return(await qt.any(e)).map((t=>t.rev))}static sqlSuffix(t,e,s){let r="";return s&&(r+=` order by "timestamp" ${s}`),r+=` limit ${t||Ht}`,e&&(r+=` offset ${e}`),r}static async getRevsByPublicKey(t){const e=new $e({name:`Output.getRevsByPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys")',values:[t]});return(await qt.any(e)).map((t=>t.rev))}static async getUnspentRevsByMod(t,e,s,r){const a=await this.getIdsByMod(t);const n=await this.getLatestRevs(a);const o=new $e({name:`Output.getUnspentRevsByMod.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(e,s,r)}`,values:[n]});return(await qt.any(o)).map((t=>t.rev))}static async getUnspentRevsByPublicKey(t,e,s,r){const a=new $e({name:`Output.getUnspentRevsByPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE $1 = ANY("publicKeys") AND "isTbcOutput" = true \n      AND NOT EXISTS (SELECT 1 FROM "Input" ip WHERE "ip"."outputSpent" = "Output"."rev") \n      ${this.sqlSuffix(e,s,r)}`,values:[t]});return(await qt.any(a)).map((t=>t.rev))}static async getUnspentRevsByModAndPublicKey(t,e,s,r,a){const n=await this.getUnspentRevsByPublicKey(e,s,r,a);const o=await this.getIdsByRevs(n);const i=new $e({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:'SELECT "rev" FROM "Output" WHERE "mod" = $1 AND "rev" = ANY($2)',values:[t,o]});const c=(await qt.any(i)).map((t=>t.rev));const u=await this.getLatestRevs(c);const l=new $e({name:`Output.getLatestRevsByModAndPublicKey.${Math.random()}`,text:`SELECT "rev" FROM "Output" WHERE "rev" = ANY($1) ${this.sqlSuffix(s,r,a)}`,values:[u]});return(await qt.any(l)).map((t=>t.rev))}static async query(t){const{publicKey:e,limit:s,offset:r,ids:a,mod:n,order:o}=t;if(s&&parseInt(s||"",10)>Ht||a&&a.length>Ht)throw new Error(`Can't fetch more than ${Ht} revs.`);if(o&&"ASC"!==o&&"DESC"!==o)throw new Error("Invalid order. Should be ASC or DESC.");return a?.length?(a.map(Te),this.getLatestRevs(a)):n&&!e?this.getUnspentRevsByMod(n,s,r,o):!n&&e?this.getUnspentRevsByPublicKey(e,s,r,o):n&&e?this.getUnspentRevsByModAndPublicKey(n,e,s,r,o):[]}}class Oe{static async select(t){return Se.select(t)}static async insert(t){return Se.insert(t)}static async listSentOutputs(t){return Se.listSentOutputs(t)}static async listReceivedOutputs(t){return Se.listReceivedOutputs(t)}static async listTxs(t){return Se.listTxs(t)}static async getLatestRev(t){return Se.getLatestRev(t)}static async query(t){return Se.query(t)}}class Re{static insert=async t=>{const e=t.flatMap((t=>{let e=[];let s=[];try{({zip:e,outData:s}=t)}catch(t){}return t.tx.outs.map(((r,a)=>{const{script:n}=r;let o=null;let c=null;let p=!1;let d=null;let m="";let h=[];let y="";if(a<e.length){const[r,n]=e[a];if(c=r,p=!0,y=s[a]?.exp||"",m=s[a]?.mod||"",d=u.sha256(Buffer.from(y)).toString("hex"),h=s[a]?._owners||[],n!==`${t.txId}:${a}`)throw new Error(`outRev: ${e[a].outRev} !== ${t.txId}:${a}`)}try{o=l.fromOutputScript(n,function(t,e){switch(dt){case"BTC":return"mainnet"===e?i.bitcoin:i.testnet;case"LTC":return"mainnet"===e?i.litecoin:i.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}(0,mt))}catch(t){}const g=n.toString("hex");const w=Math.round(r.value);return{address:o,rev:`${t.txId}:${a}`,scriptPubKey:g,satoshis:w,publicKeys:h,hash:d,previous:c,mod:m,isTbcOutput:p}}))}));return Oe.insert(e)};static listSentOutputs=async t=>Oe.listSentOutputs(t);static listReceivedOutputs=async t=>Oe.listReceivedOutputs(t);static listTxs=async t=>Oe.listTxs(t);static getLatestRev=async t=>Oe.getLatestRev(t);static query=async t=>Oe.query(t)}const be=t=>new Promise((e=>setTimeout(e,t)));const Ie=$(o);const xe=i.regtest;const{PreparedStatement:Ne}=E;class Me{static async select(t){const e=new Ne({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return qt.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,Nt);const s=[];for(let e=1;e<=t.length;e+=2)s.push(`($${e}, $${e+1})`);const r=s.join(",");const a=new Ne({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${r} ON CONFLICT DO NOTHING`,values:t});await qt.none(a)}}static async count(t){const e=t.map((t=>t.outputSpent));const s=new Ne({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const r=await qt.oneOrNone(s);return parseInt(r?.count,10)||0}}class Ce{static async select(t){return Me.select(t)}static async insert(t){return Me.insert(t)}}class Pe{static getNonCoinbaseRevs=t=>t.filter((t=>!m.isCoinbaseHash(t.input.hash))).map((({input:t,txId:e},s)=>{return{outputSpent:`${r=t.hash,c.reverseBuffer(Buffer.from(r)).toString("hex")}:${t.index}`,spendingInput:`${e}:${s}`};var r}));static insert=async t=>{const e=t.flatMap((t=>t.tx.ins.map((e=>({input:e,txId:t.txId})))));Ce.insert(this.getNonCoinbaseRevs(e))}}let Ae;try{Ae=new R({chain:dt,network:mt,url:yt})}catch(t){Wt.error(`Error creating computer, ${t.message}`),process.exit(1)}class Le{static rawTxSubscriber=async t=>{const e=t.toString("hex");if(Wt.info(`ZMQ message { rawTx:${e} }`),"08"!==e.slice(10,12))try{const t=await Ae.txFromHex({hex:e});await Re.insert([t]),await Pe.insert([t])}catch(t){Wt.error(`Error parsing transaction ${t.message} ${t.stack}`)}};static checkSyncStatus=async()=>{const t=await T((async()=>{const t=await me.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;if(Wt.info(`Zmq. Bitcoind { percentage:${e}%, blocks:${s} }`),parseFloat(t.result.verificationprogress)<=jt)throw new Error("Node not ready yet");return t}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const s=t.result.blocks;Wt.info(`BCN reaches sync end...at { bitcoind.progress:${e}%, bitcoindSyncedHeight:${s} }`)};static createWallet=async()=>{try{await me.createwallet(xt,!1,!1,"",!1,!1)}catch(t){Wt.error(`Wallet creation failed with error '${t.message}'`)}};static sub=async t=>{try{await this.createWallet(),"regtest"!==mt&&await this.checkSyncStatus(),await(async()=>{if("regtest"===mt){if(Wt.info(`Node is starting for chain ${dt} and network ${mt}, \n\n. Starting Wallet setup.`),"LTC"===dt){const{result:t}=await me.getBlockchainInfo();const e=t.blocks;if(e<Lt){const{result:t}=await me.getNewAddress("","legacy");const s=Lt-e-1;s&&await me.generateToAddress(s,t);const{result:r}=await me.getNewAddress("mweb","mweb");await me.sendToAddress(r,1),await me.generateToAddress(1,t),Wt.info("MWEB setup is complete")}}if("BTC"===dt){const{result:t}=await me.getNewAddress("","legacy");await me.generateToAddress(200,t),Wt.info("Wallet setup is complete")}}})(),Wt.info(`Bitcoin Computer Node ${It} is ready. MAX_BLOCKCHAIN_HEIGHT: ${At}`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){Wt.error(`ZMQ subscription failed with error '${t.message}'`)}}}const{PreparedStatement:Be}=E;class je{static async select(t){const e=new Be({name:`User.select.${Math.random()}`,text:'SELECT "publicKey", "clientTimestamp" FROM "User" WHERE "publicKey" = $1',values:[t]});const s=await qt.oneOrNone(e);return s?{publicKey:s.publicKey,clientTimestamp:parseInt(s.clientTimestamp,10)||0}:null}static async insert({publicKey:t,clientTimestamp:e}){const s=new Be({name:`User.insert.${Math.random()}`,text:'INSERT INTO "User"("publicKey", "clientTimestamp") VALUES ($1, $2)',values:[t,e]});await qt.none(s)}static async update({publicKey:t,clientTimestamp:e}){const s=new Be({name:`User.update.${Math.random()}`,text:'UPDATE "User" SET "clientTimestamp"=$1 WHERE "publicKey"=$2',values:[e,t]});await qt.none(s)}}class He{static async select(t){return je.select(t)}static async insert(t){return je.insert(t)}static async update(t){return je.update(t)}}const{ec:Ue}=b;const _e=new Ue("secp256k1");const ke=s();const Fe=new class{configFile;loaded=!1;load=()=>{try{const t=Yt()?"bcn.test.config.json":"bcn.config.json";const e=N(M(import.meta.url));this.configFile=g.readFileSync(x.join(e,"..","..",t)),this.loaded=!0}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void(this.loaded=!0);throw Wt.error(`Access-list failed with error '${t.message}'`),t}};middleware=({url:t},e,s)=>{if(void 0!==e.locals.authToken)if(this.loaded||(Wt.warn("Access-list failed with error 'AccessList not loaded.'. Loading now."),this.load()),void 0!==this.configFile)try{const{blacklist:t,whitelist:r}=JSON.parse(this.configFile.toString());if(t&&r)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:a}=e.locals.authToken;if(r&&!r.includes(a)||t&&t.includes(a))return void e.status(403).json({error:`Public key ${a} is not allowed.`});s()}catch(s){Wt.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s();else s()}};let Ke;h(o);try{Ke=r.createServer(ke)}catch(t){throw Wt.error(`Starting server failed with error '${t.message}'`),t}if(Wt.info(`Server listening on port ${lt}`),ke.use(e()),"dev"!==ht){const t=n({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});ke.use(t)}ke.use(t.json({limit:"100mb"})),ke.use(t.urlencoded({limit:"100mb",extended:!0})),ke.get("/",((t,e)=>e.status(200).send(`\n        <h2>Bitcoin Computer Node</h2>\n        <b>Status</b>: Healthy <br />\n        <b>Version</b>: ${It} <br />\n        <b>Chain</b>: ${dt} <br />\n        <b>Network</b>: ${mt}\n    `))),Fe.loaded&&(ke.use((async(t,e,s)=>{try{const r=t.get("Authentication");if(!r){const{method:s,url:r}=t;const a=`Auth failed with error 'no Authentication key provided' ${s} ${t.get("Host")} ${r}`;return Wt.error(a),void e.status(401).json({error:a})}const a=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(r);const{signature:n,publicKey:o,timestamp:i}=a;if(Date.now()-i>1e3*Ct*60)return void e.status(401).json({error:"Signature is too old."});const c=I.sha256().update(yt+i).digest("hex");if(!_e.keyFromPublic(o,"hex").verify(c,n)){const t="The origin and public key pair doesn't match the signature.";return void e.status(401).json({error:t})}const u=await He.select(o);if(u){if(u.clientTimestamp>=i)return void e.status(401).json({error:"Please use a fresh authentication token."});await He.update({publicKey:o,clientTimestamp:i})}else await He.insert({publicKey:o,clientTimestamp:i});e.locals.authToken=a,s()}catch(t){Wt.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),ke.use(Fe.middleware));const De=(()=>{const t=s.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await ee.select(e))}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/sent-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Re.listSentOutputs(e))}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/received-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Re.listReceivedOutputs(e))}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/list-txs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Re.listTxs(e))}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async(t,e)=>{try{const s=new URLSearchParams(t.url.split("?")[1]);const r={mod:s.get("mod"),publicKey:s.get("publicKey"),limit:s.get("limit"),order:s.get("order"),offset:s.get("offset"),ids:JSON.parse(s.get("ids"))};const a=await Re.query(r);e.status(200).json(a)}catch(s){Wt.error(`GET ${t.url} failed with error '${s.messages}'`),e.status(404).json({error:s.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await ee.getBalance(e))}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(500).json({error:"Missing input txIds."});const e=await ye.getRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/tx/post",(async({body:{hex:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input hex."});const e=await ye.sendRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Error Occured"})}catch(r){Wt.error(`POST ${e} failed with error '${r.message}\ntxHex: ${t}`),s.status(500).json({error:r.message})}})),t.get("/mine",(async({query:{count:t},url:e},s)=>{try{const{result:e}=await we.getnewaddress();if("string"!=typeof t)throw new Error("Please provide appropriate count");return await we.generatetoaddress(parseInt(t,10)||1,e),s.status(200).json({success:!0})}catch(t){return Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/:id/height",(async({params:{id:t},url:e},s)=>{try{let e=t;if("best"===t){const{result:t}=await we.getbestblockhash();e=t}const{result:r}=await we.getblockheader(e,!0);return s.status(200).json({height:r.height})}catch(t){return Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/faucet",(async({body:{address:t,value:e},url:s},r)=>{try{const s=(await we.sendtoaddress(t,parseInt(e,10)/1e8,"","")).result;const a=process.env.TEST_ADDRESS.split(";")[0];await we.generateToAddress(1,a);const n=(await we.getrawtransaction(s,1)).result.vout.findIndex((t=>1e8*t.value===parseInt(e,10)));return r.status(200).json({txId:s,vout:n,height:-1,satoshis:e})}catch(t){return Wt.error(`POST ${s} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.post("/faucetScript",(async({body:{script:t,value:e},url:s},r)=>{try{const s=Ie.makeRandom({network:xe});const a=p.p2pkh({pubkey:s.publicKey,network:xe});const{address:n}=a;const o=(await we.sendtoaddress(n,2*parseInt(e,10)/1e8,"","")).result;let i;let c=10;for(;!i;)if(i=(await ee.select(n)).filter((t=>t.txId===o))[0],!i){if(c-=1,c<=0)throw new Error("No outputs");await be(10)}const u=(await we.getrawtransaction(i.txId,1)).result;const l=new d({network:xe});l.addInput({hash:i.txId,index:i.vout,nonWitnessUtxo:Buffer.from(u.hex,"hex")}),l.addOutput({script:Buffer.from(t,"hex"),value:parseInt(e,10)}),l.signInput(0,s),l.finalizeAllInputs();const m=l.extractTransaction();let h;for(await we.sendrawtransaction(m.toHex()),c=5;!h;)if(h=(await ee.selectByScriptHex(t)).filter((t=>t.txId===m.getId()))[0],!h){if(c-=1,c<=0)throw new Error("No outputs");await be(10)}return r.status(200).json({txId:m.getId(),vout:h.vout,height:-1,satoshis:h.satoshis})}catch(t){return Wt.error(`POST ${s} failed with error '${t.message}'`),r.status(500).json({error:t.message})}})),t.get("/tx/:txId/json",(async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input txId."});const e=await ye.getRawJSON(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){Wt.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await Se.getLatestRevs(t);s.status(200).json(e)}catch(t){Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/revToId",(async({body:{rev:t},url:e},s)=>{try{if(!ve(t))return void s.status(400).json({error:"Invalid rev id"});const e=await Se.getIdByRev(t);e&&s.status(200).json(e),s.status(404).json()}catch(t){Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!Pt.some((e=>e.test(t.method))))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===fe[t]||null===fe[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const r=fe[t].trim().split(" ");if(0===e.trim().length&&0!==fe[t].trim().length)throw new Error(`Too few params provided. Expected ${r.length} Provided 0`);if(0!==e.trim().length&&0===fe[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<r.length)throw new Error(`Too few params provided. Expected ${r.length} Provided ${s.length}`);if(s.length>r.length)throw new Error(`Too many params provided. Expected ${r.length} Provided ${s.length}`);return 0===e.length?[]:s.map(((t,e)=>Ee[r[e]](t)))}(t.method,t.params);const r=e.length?await we[t.method](...e):await we[t.method]();s.status(200).json({result:r})}catch(t){Wt.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to @bitcoin-computer/lib to the latest version."})})),t})();if("mainnet"===mt)throw new Error("Mainnet is currently disabled in your jurisdiction");ke.use(`/v1/${dt}/${mt}`,De),ke.use("/v1/store",Zt),Ke.listen(lt,(()=>{Wt.info(`Rev ${It} Started web server on port ${lt}`)})).on("error",(t=>{Wt.error(t.message),process.exit(1)}));const We=new a.Subscriber;We.connect(pt),We.subscribe("rawtx"),Wt.info(`ZMQ Subscriber connected to ${pt}`),(async()=>{await(async()=>{await T((()=>qt.connect()),{startingDelay:Mt})})(),await Le.sub(We)})();
