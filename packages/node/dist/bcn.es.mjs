import t from"body-parser";import e from"cors";import s from"express";import a from"http";import*as r from"zeromq";import n from"express-rate-limit";import o from"dotenv";import i from"fs";import{networks as c,bufferUtils as u,crypto as d,address as l,payments as p,Psbt as m,Transaction as h}from"@bitcoin-computer/nakamotojs-lib";import y from"winston";import g from"winston-daily-rotate-file";import w from"pg-promise";import f from"pg-monitor";import{backOff as E}from"exponential-backoff";import{ECPairFactory as T}from"ecpair";import*as S from"@bitcoin-computer/tiny-secp256k1";import $ from"bitcoind-rpc";import v from"util";import{Computer as I}from"@bitcoin-computer/lib";import O from"elliptic";import R from"hash.js";import b,{dirname as x}from"path";import{fileURLToPath as N}from"url";o.config();const M=JSON.parse(i.readFileSync("package.json","utf8"));function C(t,e){switch(t){case"BTC":return"mainnet"===e?c.bitcoin:c.testnet;case"LTC":return"mainnet"===e?c.litecoin:c.litecoinregtest;default:throw new Error("We currently only support BTC and LTC, support for other currencies will be added soon.")}}const{PORT:A,ZMQ_URL:P,CHAIN:j,NETWORK:H,BCN_ENV:_,BCN_URL:B,DEBUG_MODE:L,POSTGRES_USER:D,POSTGRES_PASSWORD:k,POSTGRES_DB:K,POSTGRES_HOST:F,POSTGRES_PORT:U,RPC_PROTOCOL:Y,RPC_USER:W,RPC_PASSWORD:G,RPC_HOST:V,RPC_PORT:J,SERVER_VERSION:q,DEFAULT_WALLET:z,SYNC_INTERVAL_CHECK:Z,POSTGRES_MAX_PARAM_NUM:X,DB_CONNECTION_RETRY_TIME:Q,SIGNATURE_FRESHNESS_MINUTES:tt,ALLOWED_RPC_METHODS:et,NODE_MAX_PROGRESS:st,SYNC_MAX_PROGRESS:at,MAX_BLOCKCHAIN_HEIGHT:rt,MWEB_HEIGHT:nt,BC_START_HEIGHT:ot,WORKER_ID:it,NUM_WORKERS:ct,SYNC_NON_STANDARD:ut,ZMQ_WAIT_PERCENTAGE:dt,QUERY_LIMIT:lt,LOG_MAX_FILE_SIZE:pt,LOG_MAX_FILE_NUM:mt,LOG_ZIP:ht,RPC_URL:yt,RPC_BATCHSIZE:gt,RPC_CONCURRENT:wt,INDEXDB:ft,KEYDB:Et}=process.env;const Tt=parseInt(A,10)||"1031";const St=P||"tcp://node:28332";const $t=j||"LTC";const vt=H||"regtest";const It=_||"dev";const Ot=B||`http://127.0.0.1:${Tt}`;const Rt=parseInt(L,10)||1;const bt=D||"bcn";const xt=k||"bcn";const Nt=K||"bcn";const Mt=F||"127.0.0.1";const Ct=parseInt(U,10)||"5432";const At=Y||"http";const Pt=W||"bcn-admin";const jt=G||"kH4nU5Okm6-uyC0_mA5ztVNacJqZbYd_KGLl6mx722A=";const Ht=V||"node";const _t=parseInt(J,10)||19332;const Bt=M.version||q;const Lt=z||"defaultwallet";const Dt=parseInt(X,10)||1e4;const kt=parseInt(Q,10)||500;const Kt=parseInt(tt,10)||3;const Ft=et?et.split(",").map((t=>new RegExp(t))):[];const Ut=parseInt(rt||"",10)||2538171;const Yt=parseInt(nt||"",10)||432;const Wt=parseInt(ot||"",10)||25e5;const Gt=parseInt(dt||"",10)||.7;const Vt=parseInt(lt||"",10)||100;const Jt=pt||"20m";const qt=mt||"14d";const zt=!!ht;y.addColors({error:"red",warn:"yellow",info:"green",http:"magenta",debug:"white"});const Zt=y.format.combine(y.format.colorize(),y.format.timestamp({format:"YYYY-MM-DD HH:mm:ss:ms"}),y.format.json(),y.format.printf((t=>`${t.timestamp} [${t.level.slice(5).slice(0,-5)}] ${t.message}`)));const Xt={zippedArchive:zt,maxSize:Jt,maxFiles:qt,dirname:"logs"};const Qt=[];"dev"===It&&Qt.push(new y.transports.Console({format:y.format.combine(y.format.colorize(),y.format.timestamp({format:"MM-DD-YYYY HH:mm:ss"}),y.format.printf((t=>`${t.timestamp} ${t.level} ${t.message}`)))})),Rt>=0&&Qt.push(new g({filename:"error-%DATE%.log",datePattern:"YYYY-MM-DD",level:"error",...Xt})),Rt>=1&&Qt.push(new g({filename:"warn-%DATE%.log",datePattern:"YYYY-MM-DD",level:"warn",...Xt})),Rt>=2&&Qt.push(new g({filename:"info-%DATE%.log",datePattern:"YYYY-MM-DD",level:"info",...Xt})),Rt>=3&&Qt.push(new g({filename:"http-%DATE%.log",datePattern:"YYYY-MM-DD",level:"http",...Xt})),Rt>=4&&Qt.push(new g({filename:"debug-%DATE%.log",datePattern:"YYYY-MM-DD",level:"debug",...Xt})),Qt.push(new g({filename:"logs-%DATE%.log",datePattern:"YYYY-MM-DD"}));const te=y.createLogger({levels:{error:0,warn:1,info:2,http:3,debug:4},format:Zt,transports:Qt,exceptionHandlers:[new y.transports.File({filename:"logs/exceptions.log"})],rejectionHandlers:[new y.transports.File({filename:"logs/rejections.log"})]});const ee=()=>"dev"===It;const se={error:(t,e)=>{if(e.cn){const{host:s,port:a,database:r,user:n,password:o}=e.cn;te.debug(`Waiting for db to start { message:${t.message} host:${s}, port:${a}, database:${r}, user:${n}, password: ${o}`)}},noWarnings:!0};ee()&&Rt>0&&(f.isAttached()?f.detach():(f.attach(se),f.setTheme("matrix")));const ae=w(se)({host:Mt,port:Ct,database:Nt,user:bt,password:xt,allowExitOnIdle:!0,idleTimeoutMillis:100});const{PreparedStatement:re}=w;class ne{static async select(t){const e=new re({name:`OffChain.select.${Math.random()}`,text:'SELECT "data" FROM "OffChain" WHERE "id" = $1',values:[t]});return ae.oneOrNone(e)}static async insert({id:t,data:e}){const s=new re({name:`OffChain.insert.${Math.random()}`,text:'INSERT INTO "OffChain" ("id", "data") VALUES ($1, $2) ON CONFLICT DO NOTHING',values:[t,e]});return ae.none(s)}static async delete(t){const e=new re({name:`OffChain.delete.${Math.random()}`,text:'WITH deleted AS (DELETE FROM "OffChain" WHERE "id" = $1 RETURNING *) SELECT count(*) FROM deleted;',values:[t]});return(await ae.any(e))[0].count>0}}class oe{static async select(t){const e=await ne.select(t);return e?.data||null}static async insert(t){return ne.insert(t)}static async delete(t){return ne.delete(t)}}const ie=s.Router();ie.get("/:id",(async({params:{id:t},url:e},s)=>{try{const e=await oe.select(t);e?s.status(200).json(e):s.status(403).json({error:"No entry found."})}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),ie.post("/",(async(t,e)=>{const{body:{data:s},url:a}=t;try{const r=d.sha256(Buffer.from(s)).toString("hex");await oe.insert({id:r,data:s});const n=`${["localhost","127.0.0.1"].includes(t.host)?"http":"https"}://${t.get("host")}/store/${r}`;te.info(`Off-chain POST ${a} succeeded with url '${n}'`),e.status(201).json({_url:n})}catch(t){te.error(`POST ${a} failed with error '${t.message}'`),e.status(500).json({error:t.message})}})),ie.delete("/:id",(async(t,e)=>{e.status(500).json({error:"Deletions are not supported yet."})}));const{PreparedStatement:ce}=w;class ue{static async getBalance(t){const e=new ce({name:`Utxos.getBalance.${Math.random()}`,text:'SELECT sum("satoshis") as "satoshis" FROM "Utxos" WHERE "address" = $1',values:[t]});const s=await ae.oneOrNone(e);return parseInt(s?.satoshis,10)||0}static async select(t){const e=new ce({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "address" = $1',values:[t]});return(await ae.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByScriptHex(t){const e=new ce({name:`Utxos.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout" FROM "Utxos" WHERE "scriptPubKey" = $1',values:[t]});return(await ae.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)||0})))}static async selectByPk(t){const e=new ce({name:`Utxos.selectByPk.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev", split_part(rev, \':\', 1) AS "txId", cast(split_part(rev, \':\', 2) as INTEGER) AS "vout", "publicKeys" FROM "Utxos" WHERE $1 = ANY ("publicKeys")',values:[t]});return(await ae.any(e)).map((t=>({...t,satoshis:parseInt(t.satoshis,10)})))}}class de{static async getBalance(t){return ue.getBalance(t)}static async select(t){return ue.select(t)}static async selectByScriptHex(t){return ue.selectByScriptHex(t)}static async selectByPk(t){return ue.selectByPk(t)}}class le{static getBalance=async t=>de.getBalance(t);static select=async t=>de.select(t);static selectByScriptHex=async t=>de.selectByScriptHex(t);static selectByPk=async t=>de.selectByPk(t)}function pe(t){return/^[0-9A-Fa-f]{64}:\d+$/.test(t)}function me(t){if(!pe(t))throw new Error("Invalid rev")}const{PreparedStatement:he}=w;class ye{static async query(t){const{publicKey:e,hash:s,limit:a,offset:r,order:n,ids:o,mod:i}=t;if(a&&parseInt(a||"",10)>Vt||o&&o.length>Vt)throw new Error(`Can't fetch more than ${Vt} revs.`);if(n&&"ASC"!==n&&"DESC"!==n)throw new Error("Invalid order");let c;c=o?.length?'SELECT "rev", "id", array_position($1, "id") as ord\n        FROM "NonStandard" \n        WHERE true ':'SELECT "rev"\n        FROM "NonStandard"\n        WHERE true ';const u=[];s&&(u.push(s),c+=` AND "hash" = $${u.length}`),i&&(u.push(i),c+=` AND "mod" = $${u.length}`),o&&(o.map(me),u.push(o),c+=` AND "id" = ANY ($${u.length})`),e&&(u.push(e),c+=` AND $${u.length} = ANY ("publicKeys")`),n?(c+=` order by "lastUpdated" ${n}`,o?.length&&(c+=", ord")):o?.length&&(c+=" order by ord"),u.push(a||Vt),c+=` limit $${u.length}`,r&&(u.push(r),c+=` offset $${u.length}`);const d=new he({name:`NonStandard.query.${Math.random()}`,text:c,values:u});return(await ae.any(d)).map((t=>t.rev))}static async insert({id:t,rev:e,publicKeys:s,hash:a,mod:r}){const n=new he({name:`NonStandard.insert.${Math.random()}`,text:'INSERT INTO "NonStandard"("id", "rev", "publicKeys", "hash", "mod") VALUES ($1, $2, $3, $4, $5) ON CONFLICT DO NOTHING',values:[t,e,s,a,r]});await ae.none(n)}static async update({id:t,rev:e,publicKeys:s}){const a=new he({name:`NonStandard.update.${Math.random()}`,text:'UPDATE "NonStandard" SET "rev"=$2, "publicKeys"=$3 WHERE "id" = $1',values:[t,e,s]});return ae.none(a)}static async delete({rev:t}){const e=new he({name:`NonStandard.delete.${Math.random()}`,text:'DELETE FROM "NonStandard" WHERE "rev" = $1',values:[t]});await ae.none(e)}static async getRevsByIds(t){if(t&&t.length>Vt)throw new Error(`Can't fetch more than ${Vt} revs.`);const e=new he({name:`NonStandard.getRevsByIds.${Math.random()}`,text:'SELECT "rev" FROM "NonStandard" WHERE "id" LIKE ANY($1)',values:[[t]]});return ae.any(e)}static async select(t){const e=new he({name:`NonStandard.select.${Math.random()}`,text:'SELECT "id", "hash", "mod" FROM "NonStandard" WHERE "rev" = $1',values:[t]});return ae.oneOrNone(e)}}class ge{static async select(t){return ye.select(t)}static async query(t){return ye.query(t)}static async getRevsByIds(t){return ye.getRevsByIds(t)}static async insert(t){return ye.insert(t)}static async update(t){return ye.update(t)}static async delete(t){return ye.delete({rev:t})}}const{PreparedStatement:we}=w;class fe{static async getId(t){const e=new we({name:`RevToId.select.${Math.random()}`,text:'SELECT "id" FROM "RevToId" WHERE "rev" = $1',values:[t]});const s=await ae.oneOrNone(e);return s?.id}static async insert(t){const e=new we({name:`RevToId.insert.${Math.random()}`,text:'INSERT INTO "RevToId"("rev", "id") VALUES ($1, $2)  ON CONFLICT DO NOTHING',values:[t.rev,t.id]});await ae.none(e)}}class Ee{static async getId(t){return fe.getId(t)}static async insert(t){return fe.insert(t)}}class Te{static add=async t=>{const{zip:e,outData:s}=t;for(let t=0;t<e.length;t+=1){const[a,r]=e[t];const{exp:n="",_owners:o=[],mod:i=""}=s[t]||{};if(!a&&r)me(r),await ge.insert({id:r,rev:r,publicKeys:o,hash:d.sha256(Buffer.from(n)).toString("hex"),mod:i}),await Ee.insert({rev:r,id:r});else if(a&&r){const{id:t,hash:e,mod:s}=await ge.select(a)||{};await ge.update({id:t,rev:r,publicKeys:o,hash:e,mod:s}),await Ee.insert({rev:r,id:t})}else a&&!r&&await ge.delete(a)}};static query=async t=>ge.query(t);static getRevsByIds=async t=>(await ge.getRevsByIds(t)).map((t=>t.rev))}const Se=new $({protocol:At,user:Pt,pass:jt,host:Ht,port:_t});const $e=v.promisify($.prototype.createwallet.bind(Se));const ve=v.promisify($.prototype.generateToAddress.bind(Se));const Ie=v.promisify($.prototype.getaddressinfo.bind(Se));const Oe=v.promisify($.prototype.getBlock.bind(Se));const Re=v.promisify($.prototype.getBlockchainInfo.bind(Se));const be=v.promisify($.prototype.getBlockHash.bind(Se));const xe=v.promisify($.prototype.getRawTransaction.bind(Se));const Ne=v.promisify($.prototype.getRawTransaction.bind(Se));const Me=v.promisify($.prototype.getTransaction.bind(Se));const Ce=v.promisify($.prototype.getNewAddress.bind(Se));const Ae={createwallet:$e,generateToAddress:ve,getaddressinfo:Ie,getBlock:Oe,getBlockchainInfo:Re,getBlockHash:be,getRawTransaction:xe,getTransaction:Me,importaddress:v.promisify($.prototype.importaddress.bind(Se)),listunspent:v.promisify($.prototype.listunspent.bind(Se)),sendRawTransaction:v.promisify($.prototype.sendRawTransaction.bind(Se)),getNewAddress:Ce,sendToAddress:v.promisify($.prototype.sendToAddress.bind(Se)),getRawTransactionJSON:Ne};class Pe{static async getTransaction(t){const{result:e}=await Ae.getTransaction(t);return e}static async getBulkTransactions(t){return(await Promise.all(t.map((t=>Ae.getRawTransaction(t))))).map((t=>t.result))}static async getRawTransactionsJSON(t){return{txId:(e=(await Ae.getRawTransactionJSON(t,1)).result).txid,txHex:e.hex,vsize:e.vsize,version:e.version,locktime:e.locktime,ins:e.vin.map((t=>t.coinbase?{coinbase:t.coinbase,sequence:t.sequence}:{txId:t.txid,vout:t.vout,script:t.scriptSig.hex,sequence:t.sequence})),outs:e.vout.map((t=>{let e;return t.scriptPubKey.addresses?[e]=t.scriptPubKey.addresses:e=t.scriptPubKey.address?t.scriptPubKey.address:void 0,{address:e,script:t.scriptPubKey.hex,value:Math.round(1e8*t.value)}}))};var e}static async sendRawTransaction(t){const{result:e,error:s}=await Ae.sendRawTransaction(t);if(s)throw te.error(s),new Error("Error sending transaction");return e}static getUtxos=async t=>(void 0===(await Ae.getaddressinfo(t)).result.timestamp&&(te.info(`Importing address: ${t}`),await Ae.importaddress(t,!1)),(await Ae.listunspent(0,999999,[t])).result)}class je{static get=async t=>Pe.getTransaction(t);static getRaw=async t=>Pe.getBulkTransactions(t);static getRawJSON=async t=>Pe.getRawTransactionsJSON(t);static sendRaw=async t=>Pe.sendRawTransaction(t);static getUtxos=async t=>Pe.getUtxos(t)}const He=new $({protocol:At,user:Pt,pass:jt,host:Ht,port:_t});const _e={};const Be=JSON.parse(JSON.stringify($.callspec));Object.keys(Be).forEach((t=>{Be[t.toLowerCase()]=Be[t]}));const Le={str:t=>t.toString(),string:t=>t.toString(),int:t=>parseFloat(t),float:t=>parseFloat(t),bool:t=>!0===t||"1"===t||1===t||"true"===t||"true"===t.toString().toLowerCase(),obj:t=>"string"==typeof t?JSON.parse(t):t};try{Object.keys($.prototype).forEach((t=>{if(t&&"function"==typeof $.prototype[t]){const e=t.toLowerCase();_e[t]=v.promisify($.prototype[t].bind(He)),_e[e]=v.promisify($.prototype[e].bind(He))}}))}catch(t){te.error(`Error occurred while binding RPC methods: ${t.message}`)}const{PreparedStatement:De}=w;class ke{static async listSentOutputs(t){const e=new De({name:`Output.listSentTxs.${Math.random()}`,text:'SELECT "Input"."spendingInput" AS "output", "Output"."satoshis" AS "amount"\n        FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent" \n        WHERE "Output"."address" = $1',values:[t]});return(await ae.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listReceivedOutputs(t){const e=new De({name:`Output.listReceivedTxs.${Math.random()}`,text:'SELECT "Output"."rev" as "output", "Output"."satoshis" as "amount" FROM "Output" WHERE "address" = $1',values:[t]});return(await ae.any(e)).map((t=>({...t,amount:parseInt(t.amount,10)||0})))}static async listTxs(t){const e=new De({name:`Output.listTxs.${Math.random()}`,text:' -- List all txs sent from a given address\n            WITH SENT AS (\n              SELECT split_part("Input"."spendingInput",\':\',1) as "txId", SUM("Output".satoshis) as "satoshis"\n              FROM "Output" INNER JOIN "Input" ON "Output".rev = "Input"."outputSpent"  \n              WHERE "Output".address = $1\n              GROUP BY split_part("Input"."spendingInput",\':\',1)\n            )\n            \n            -- List all tx received from a given address\n            , RECEIVED AS (\n              SELECT SPLIT_PART("Output"."rev",\':\',1) as "txId", SUM("Output"."satoshis") as "satoshis" \n              FROM "Output" \n              WHERE "address" = $1\n              GROUP BY "txId"\n            )\n            SELECT\n              RECEIVED."txId", \n              coalesce(SENT."satoshis", 0) as "inputsSatoshis", \n              coalesce(RECEIVED."satoshis", 0) as "outputsSatoshis", \n              coalesce(RECEIVED."satoshis",0) - coalesce(SENT."satoshis",0) as "satoshis"\n            FROM\n                SENT RIGHT JOIN RECEIVED ON SENT."txId" = RECEIVED."txId" ;',values:[t]});const s=(await ae.any(e)).map((t=>({...t,inputsSatoshis:parseInt(t.inputsSatoshis,10)||0,outputsSatoshis:parseInt(t.outputsSatoshis,10)||0,satoshis:parseInt(t.satoshis,10)||0})));return{sentTxs:s.filter((t=>t.satoshis<0)).map((t=>({...t,satoshis:Math.abs(t.satoshis)}))),receivedTxs:s.filter((t=>t.satoshis>=0))}}static async select(t){const e=new De({name:`Output.select.${Math.random()}`,text:'SELECT "address", "satoshis", "scriptPubKey", "rev" FROM "Output" WHERE "address" = $1',values:[t]});return ae.any(e)}static async insert(t){const e=t.flatMap((t=>[t.rev,t.address,t.satoshis,t.scriptPubKey,t.publicKeys]));for(;e.length;){const t=e.splice(0,Dt);const s=[];for(let e=1;e<=t.length;e+=5)s.push(`($${e}, $${e+1}, $${e+2}, $${e+3}, $${e+4})`);const a=s.join(",");const r=new De({name:`Output.insert.${Math.random()}`,text:`INSERT INTO "Output"("rev", "address", "satoshis", "scriptPubKey", "publicKeys") VALUES ${a}  ON CONFLICT DO NOTHING`,values:t});await ae.none(r)}}}class Ke{static async select(t){return ke.select(t)}static async insert(t){return ke.insert(t)}static async listSentOutputs(t){return ke.listSentOutputs(t)}static async listReceivedOutputs(t){return ke.listReceivedOutputs(t)}static async listTxs(t){return ke.listTxs(t)}}class Fe{static insert=async t=>{const e=t.flatMap((t=>t.tx.outs.map(((e,s)=>{const{script:a}=e;let r;let n;try{r=l.fromOutputScript(a,C($t,vt))}catch(t){r=null}try{n=p.p2ms({output:a,network:C($t,vt)}).pubkeys.map((t=>t.toString("hex")))}catch(t){n=null}const o=a.toString("hex");const i=Math.round(e.value);return{address:r,rev:`${t.txId}:${s}`,scriptPubKey:o,satoshis:i,publicKeys:n}}))));return Ke.insert(e)};static listSentOutputs=async t=>Ke.listSentOutputs(t);static listReceivedOutputs=async t=>Ke.listReceivedOutputs(t);static listTxs=async t=>Ke.listTxs(t)}const Ue=t=>new Promise((e=>setTimeout(e,t)));const Ye=T(S);const We=c.regtest;const{PreparedStatement:Ge}=w;class Ve{static async select(t){const e=new Ge({name:`Input.select.${Math.random()}`,text:'SELECT "outputSpent" FROM "Input" WHERE "outputSpent" = $1',values:[t]});return ae.any(e)}static async insert(t){const e=t.flatMap((t=>[t.outputSpent,t.spendingInput]));for(;e.length;){const t=e.splice(0,Dt);const s=[];for(let e=1;e<=t.length;e+=2)s.push(`($${e}, $${e+1})`);const a=s.join(",");const r=new Ge({name:`Input.insert.${Math.random()}`,text:`INSERT INTO "Input"("outputSpent", "spendingInput") VALUES ${a} ON CONFLICT DO NOTHING`,values:t});await ae.none(r)}}static async count(t){const e=t.map((t=>t.outputSpent));const s=new Ge({name:`Input.belong.${Math.random()}`,text:'SELECT count(*) FROM "Input" WHERE "outputSpent" LIKE ANY ($1)',values:[[e]]});const a=await ae.oneOrNone(s);return parseInt(a?.count,10)||0}}class Je{static async select(t){return Ve.select(t)}static async insert(t){return Ve.insert(t)}}class qe{static getNonCoinbaseRevs=t=>t.filter((t=>!h.isCoinbaseHash(t.input.hash))).map((({input:t,txId:e},s)=>{return{outputSpent:`${a=t.hash,u.reverseBuffer(Buffer.from(a)).toString("hex")}:${t.index}`,spendingInput:`${e}:${s}`};var a}));static insert=async t=>{Je.insert(this.getNonCoinbaseRevs(t))}}let ze;try{ze=new I({chain:$t,network:vt,url:Ot})}catch(t){te.error(`Error creating computer, ${t.message}`),process.exit(1)}class Ze{static syncTx=async t=>{await Fe.insert([t]),await qe.insert(t.tx.ins.map((e=>({input:e,txId:t.txId})))),t.isBcTx($t,vt)&&await Te.add(t)};static rawTxSubscriber=async t=>{const e=t.toString("hex");if(te.info(`ZMQ message { rawTx:${e} }`),"08"!==e.slice(10,12)){let t;try{t=await ze.txFromHex({hex:e})}catch(t){te.error(`RawTxSubscriber failed with error '${t.message} ${t.stack}'`)}try{await this.syncTx(t)}catch(t){te.error(`Error parsing transaction ${t.message} ${t.stack}`)}}};static checkSyncStatus=async()=>{const t=await E((async()=>{const t=await Ae.getBlockchainInfo();const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const{blocks:s}=t.result;if(te.info(`Zmq. Bitcoind { percentage:${e}%, blocks:${s} }`),parseFloat(t.result.verificationprogress)<=Gt)throw new Error("Node not ready yet");return t}),{startingDelay:6e4,timeMultiple:1,numOfAttempts:8760});const e=(100*parseFloat(t.result.verificationprogress)).toFixed(4);const s=t.result.blocks;te.info(`BCN reaches sync end...at { bitcoind.progress:${e}%, bitcoindSyncedHeight:${s} }`)};static createWallet=async()=>{try{await Ae.createwallet(Lt,!1,!1,"",!1,!1)}catch(t){te.error(`Wallet creation failed with error '${t.message}'`)}};static sub=async t=>{try{await this.createWallet(),"regtest"!==vt&&await this.checkSyncStatus(),await(async()=>{if("regtest"===vt){if(te.info(`Node is starting for chain ${$t} and network ${vt}, \n\n. Starting Wallet setup.`),"LTC"===$t){const{result:t}=await Ae.getBlockchainInfo();const e=t.blocks;if(e<Yt){const{result:t}=await Ae.getNewAddress("","legacy");const s=Yt-e-1;s&&await Ae.generateToAddress(s,t);const{result:a}=await Ae.getNewAddress("mweb","mweb");await Ae.sendToAddress(a,1),await Ae.generateToAddress(1,t),te.info("MWEB setup is complete")}}if("BTC"===$t){const{result:t}=await Ae.getNewAddress("","legacy");await Ae.generateToAddress(200,t),te.info("Wallet setup is complete")}}})(),te.info(`Bitcoin Computer Node ${Bt} is ready. MAX_BLOCKCHAIN_HEIGHT: ${Ut}`);for await(const[,e]of t)await this.rawTxSubscriber(e)}catch(t){te.error(`ZMQ subscription failed with error '${t.message}'`)}}}const{PreparedStatement:Xe}=w;class Qe{static async select(t){const e=new Xe({name:`User.select.${Math.random()}`,text:'SELECT "publicKey", "clientTimestamp" FROM "User" WHERE "publicKey" = $1',values:[t]});const s=await ae.oneOrNone(e);return s?{publicKey:s.publicKey,clientTimestamp:parseInt(s.clientTimestamp,10)||0}:null}static async insert({publicKey:t,clientTimestamp:e}){const s=new Xe({name:`User.insert.${Math.random()}`,text:'INSERT INTO "User"("publicKey", "clientTimestamp") VALUES ($1, $2)',values:[t,e]});await ae.none(s)}static async update({publicKey:t,clientTimestamp:e}){const s=new Xe({name:`User.update.${Math.random()}`,text:'UPDATE "User" SET "clientTimestamp"=$1 WHERE "publicKey"=$2',values:[e,t]});await ae.none(s)}}class ts{static async select(t){return Qe.select(t)}static async insert(t){return Qe.insert(t)}static async update(t){return Qe.update(t)}}const{ec:es}=O;const ss=new es("secp256k1");const as=s();const rs=new class{configFile;loaded=!1;load=()=>{try{const t=ee()?"bcn.test.config.json":"bcn.config.json";const e=x(N(import.meta.url));this.configFile=i.readFileSync(b.join(e,"..","..",t)),this.loaded=!0}catch(t){if(t.message.includes("ENOENT: no such file or directory"))return void(this.loaded=!0);throw te.error(`Access-list failed with error '${t.message}'`),t}};middleware=({url:t},e,s)=>{if(void 0!==e.locals.authToken)if(this.loaded||(te.warn("Access-list failed with error 'AccessList not loaded.'. Loading now."),this.load()),void 0!==this.configFile)try{const{blacklist:t,whitelist:a}=JSON.parse(this.configFile.toString());if(t&&a)return void e.status(403).json({error:"Cannot enforce blacklist and whitelist at the same time."});const{publicKey:r}=e.locals.authToken;if(a&&!a.includes(r)||t&&t.includes(r))return void e.status(403).json({error:`Public key ${r} is not allowed.`});s()}catch(s){te.error(`Authorization failed at ${t} with error: '${s.message}'`),e.status(403).json({error:s.message})}else s();else s()}};let ns;try{ns=a.createServer(as)}catch(t){throw te.error(`Starting server failed with error '${t.message}'`),t}if(te.info(`Server listening on port ${Tt}`),as.use(e()),"dev"!==It){const t=n({windowMs:9e5,max:300,standardHeaders:!0,legacyHeaders:!1});as.use(t)}as.use(t.json({limit:"100mb"})),as.use(t.urlencoded({limit:"100mb",extended:!0})),as.get("/",((t,e)=>e.status(200).send(`<h2>Bitcoin Computer Node</h2> <b>Status</b> healthy <br /><b>Version</b> ${Bt}`))),rs.loaded&&(as.use((async(t,e,s)=>{try{const a=t.get("Authentication");if(!a){const{method:s,url:a}=t;const r=`Auth failed with error 'no Authentication key provided' ${s} ${t.get("Host")} ${a}`;return te.error(r),void e.status(401).json({error:r})}const r=(t=>{const e=t.split(" ");if(2!==e.length||"Bearer"!==e[0])throw new Error("Authentication header is invalid.");const s=Buffer.from(e[1],"base64").toString().split(":");if(3!==s.length)throw new Error;return{signature:s[0],publicKey:s[1],timestamp:parseInt(s[2],10)}})(a);const{signature:n,publicKey:o,timestamp:i}=r;if(Date.now()-i>1e3*Kt*60)return void e.status(401).json({error:"Signature is too old."});const c=R.sha256().update(Ot+i).digest("hex");if(!ss.keyFromPublic(o,"hex").verify(c,n)){const t="The origin and public key pair doesn't match the signature.";return void e.status(401).json({error:t})}const u=await ts.select(o);if(u){if(u.clientTimestamp>=i)return void e.status(401).json({error:"Please use a fresh authentication token."});await ts.update({publicKey:o,clientTimestamp:i})}else await ts.insert({publicKey:o,clientTimestamp:i});e.locals.authToken=r,s()}catch(t){te.error(`Auth failed with error '${t.message}'`),e.status(401).json({error:t.message})}})),as.use(rs.middleware));const os=(()=>{const t=s.Router();return t.get("/wallet/:address/utxos",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await le.select(e))}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/sent-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Fe.listSentOutputs(e))}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/received-outputs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Fe.listReceivedOutputs(e))}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/wallet/:address/list-txs",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await Fe.listTxs(e))}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.get("/non-standard-utxos",(async(t,e)=>{try{const s=new URLSearchParams(t.url.split("?")[1]);const a={mod:s.get("mod"),publicKey:s.get("publicKey"),hash:s.get("hash"),limit:s.get("limit"),order:s.get("order"),offset:s.get("offset"),ids:JSON.parse(s.get("ids"))};const r=await Te.query(a);e.status(200).json(r)}catch(s){te.error(`GET ${t.url} failed with error '${s.messages}'`),e.status(404).json({error:s.message})}})),t.get("/address/:address/balance",(async({params:t,url:e},s)=>{try{const{address:e}=t;s.status(200).json(await le.getBalance(e))}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/tx/bulk",(async({body:{txIds:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(500).json({error:"Missing input txIds."});const e=await je.getRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){te.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/tx/post",(async({body:{hex:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input hex."});const e=await je.sendRaw(t);e?s.status(200).json(e):s.status(404).json({error:"Error Occured"})}catch(a){te.error(`POST ${e} failed with error '${a.message}\ntxHex: ${t}`),s.status(500).json({error:a.message})}})),t.get("/mine",(async({query:{count:t},url:e},s)=>{try{const{result:e}=await _e.getnewaddress();if("string"!=typeof t)throw new Error("Please provide appropriate count");return await _e.generatetoaddress(parseInt(t,10)||1,e),s.status(200).json({success:!0})}catch(t){return te.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.get("/:id/height",(async({params:{id:t},url:e},s)=>{try{let e=t;if("best"===t){const{result:t}=await _e.getbestblockhash();e=t}const{result:a}=await _e.getblockheader(e,!0);return s.status(200).json({height:a.height})}catch(t){return te.error(`POST ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/faucet",(async({body:{address:t,value:e},url:s},a)=>{try{const s=(await _e.sendtoaddress(t,parseInt(e,10)/1e8,"","")).result;const r=(await _e.getrawtransaction(s,1)).result.vout.findIndex((t=>1e8*t.value===parseInt(e,10)));return a.status(200).json({txId:s,vout:r,height:-1,satoshis:e})}catch(t){return te.error(`POST ${s} failed with error '${t.message}'`),a.status(500).json({error:t.message})}})),t.post("/faucetScript",(async({body:{script:t,value:e},url:s},a)=>{try{const s=Ye.makeRandom({network:We});const r=p.p2pkh({pubkey:s.publicKey,network:We});const{address:n}=r;const o=(await _e.sendtoaddress(n,2*parseInt(e,10)/1e8,"","")).result;let i;let c=10;for(;!i;)if(i=(await le.select(n)).filter((t=>t.txId===o))[0],!i){if(c-=1,c<=0)throw new Error("No outputs");await Ue(10)}const u=(await _e.getrawtransaction(i.txId,1)).result;const d=new m({network:We});d.addInput({hash:i.txId,index:i.vout,nonWitnessUtxo:Buffer.from(u.hex,"hex")}),d.addOutput({script:Buffer.from(t,"hex"),value:parseInt(e,10)}),d.signInput(0,s),d.finalizeAllInputs();const l=d.extractTransaction();let h;for(await _e.sendrawtransaction(l.toHex()),c=5;!h;)if(h=(await le.selectByScriptHex(t)).filter((t=>t.txId===l.getId()))[0],!h){if(c-=1,c<=0)throw new Error("No outputs");await Ue(10)}return a.status(200).json({txId:l.getId(),vout:h.vout,height:-1,satoshis:h.satoshis})}catch(t){return te.error(`POST ${s} failed with error '${t.message}'`),a.status(500).json({error:t.message})}})),t.get("/tx/:txId/json",(async({params:{txId:t},url:e},s)=>{try{if(!t)return void s.status(500).json({error:"Missing input txId."});const e=await je.getRawJSON(t);e?s.status(200).json(e):s.status(404).json({error:"Not found"})}catch(t){te.error(`GET ${e} failed with error '${t.message}'`),s.status(500).json({error:t.message})}})),t.post("/revs",(async({body:{ids:t},url:e},s)=>{try{if(void 0===t||0===t.length)return void s.status(404).json({error:"Missing input object ids."});const e=await Te.getRevsByIds(t);s.status(200).json(e)}catch(t){te.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/revToId",(async({body:{rev:t},url:e},s)=>{try{if(!pe(t))return void s.status(400).json({error:"Invalid rev id"});const e=await Ee.getId(t);e&&s.status(200).json(e),s.status(404).json()}catch(t){te.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/rpc",(async({body:t,url:e},s)=>{try{if(!t||!t.method)throw new Error("Please provide appropriate RPC method name");if(!Ft.some((e=>e.test(t.method))))throw new Error("Method is not allowed");const e=function(t,e){if(void 0===Be[t]||null===Be[t])throw new Error("This RPC method does not exist, or not supported");const s=e.trim().split(" ");const a=Be[t].trim().split(" ");if(0===e.trim().length&&0!==Be[t].trim().length)throw new Error(`Too few params provided. Expected ${a.length} Provided 0`);if(0!==e.trim().length&&0===Be[t].trim().length)throw new Error(`Too many params provided. Expected 0 Provided ${s.length}`);if(s.length<a.length)throw new Error(`Too few params provided. Expected ${a.length} Provided ${s.length}`);if(s.length>a.length)throw new Error(`Too many params provided. Expected ${a.length} Provided ${s.length}`);return 0===e.length?[]:s.map(((t,e)=>Le[a[e]](t)))}(t.method,t.params);const a=e.length?await _e[t.method](...e):await _e[t.method]();s.status(200).json({result:a})}catch(t){te.error(`POST ${e} failed with error '${t.message}'`),s.status(404).json({error:t.message})}})),t.post("/non-standard-utxo",(async(t,e)=>{e.status(500).json({error:"Please upgrade to @bitcoin-computer/lib to the latest version."})})),t})();as.use(`/v1/${$t}/${vt}`,os),as.use("/v1/store",ie),ns.listen(Tt,(()=>{te.info(`Rev ${Bt} Started web server on port ${Tt} BC_START_HEIGHT ${Wt}`)})).on("error",(t=>{te.error(t.message),process.exit(1)}));const is=new r.Subscriber;is.connect(St),is.subscribe("rawtx"),te.info(`ZMQ Subscriber connected to ${St}`),(async()=>{await(async()=>{await E((()=>ae.connect()),{startingDelay:kt})})(),await Ze.sub(is)})();
